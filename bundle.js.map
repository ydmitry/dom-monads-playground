{"version":3,"sources":["webpack:///webpack/bootstrap e47f4c34504939bc76df","webpack:///./index.js","webpack:///./~/ramda/src/curry.js","webpack:///./~/ramda/src/internal/_curry1.js","webpack:///./~/ramda/src/curryN.js","webpack:///./~/ramda/src/internal/_arity.js","webpack:///./~/ramda/src/internal/_curry2.js","webpack:///./~/ramda/src/internal/_curryN.js","webpack:///./~/ramda/src/pipe.js","webpack:///./~/ramda/src/internal/_pipe.js","webpack:///./~/ramda/src/reduce.js","webpack:///./~/ramda/src/internal/_curry3.js","webpack:///./~/ramda/src/internal/_reduce.js","webpack:///./~/ramda/src/internal/_xwrap.js","webpack:///./~/ramda/src/bind.js","webpack:///./~/ramda/src/isArrayLike.js","webpack:///./~/ramda/src/internal/_isArray.js","webpack:///./~/ramda/src/tail.js","webpack:///./~/ramda/src/internal/_checkForMethod.js","webpack:///./~/ramda/src/internal/_slice.js","webpack:///./~/ramda/src/slice.js","webpack:///./~/ramda/src/map.js","webpack:///./~/ramda/src/internal/_dispatchable.js","webpack:///./~/ramda/src/internal/_isTransformer.js","webpack:///./~/ramda/src/internal/_map.js","webpack:///./~/ramda/src/internal/_xmap.js","webpack:///./~/ramda/src/internal/_xfBase.js","webpack:///./~/ramda/src/lift.js","webpack:///./~/ramda/src/liftN.js","webpack:///./~/ramda/src/ap.js","webpack:///./~/ramda/src/internal/_concat.js","webpack:///./~/ramda/src/internal/_hasMethod.js","webpack:///./~/ramda/src/tap.js","webpack:///./~/ramda/src/prop.js","webpack:///./~/ramda/src/compose.js","webpack:///./~/ramda/src/reverse.js","webpack:///./~/ramda/src/flip.js","webpack:///./~/baconjs/dist/Bacon.js","webpack:///(webpack)/buildin/module.js","webpack:///(webpack)/buildin/amd-define.js","webpack:///(webpack)/buildin/amd-options.js","webpack:///./~/data.future/lib/index.js","webpack:///./~/data.future/lib/future.js","webpack:///./~/data.future/lib/memoised.js","webpack:///./io.js","webpack:///./colors.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;0CCtCkB,CAAiB;;;;yCAClB,CAAgB;;;;wCACjB,EAAe;;;;yCACd,EAAgB;;;;wCACjB,EAAe;;;;yCACd,EAAgB;;;;4CACb,EAAmB;;;;yCACtB,EAAgB;;;;oCACf,EAAS;;;;uCACR,EAAa;;;;+BACgB,EAAI;;mCACR,EAAU;;AAEtD,oBAAY,CAAC;;;;AAIb,KAAM,MAAM,GAAG,gCAAM,UAAU,KAAK,EAAE,MAAM,EAAE;AAC1C,YAAO,qBAAM,eAAe,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;EAC/C,CAAC,CAAC;;AAEH,KAAM,GAAG,GAAG,SAAN,GAAG,CAAY,CAAC,EAAE;AACpB,YAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AACf,YAAO,CAAC,CAAC;EACZ,CAAC;;AAEF,KAAM,IAAI,GAAG,gCAAM,UAAS,CAAC,EAAE,MAAM,EAAE;AACnC,YAAO,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;EAC9B,CAAC,CAAC;;AAEH,KAAM,KAAK,GAAG,gCAAM,UAAS,CAAC,EAAE,OAAO,EAAE;AACrC,YAAO,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;EAC3B,CAAC,CAAC;;AAEH,KAAM,OAAO,GAAG,gCAAM,UAAS,EAAE,EAAE,CAAC,EAAE;AAClC,OAAE,CAAC,SAAS,GAAG,CAAC,CAAC;AACjB,YAAO,EAAE,CAAC;EACb,CAAC,CAAC;;AAEH,KAAM,kBAAkB,GAAG,gCAAM,UAAS,EAAE,EAAE,KAAK,EAAE;AACjD,OAAE,CAAC,KAAK,CAAC,eAAe,GAAG,KAAK,CAAC;AACjC,YAAO,EAAE,CAAC;EACb,CAAC,CAAC;;AAEH,KAAM,QAAQ,GAAG,gCAAM,UAAS,EAAE,EAAE,KAAK,EAAE;AACvC,OAAE,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC;AACvB,YAAO,EAAE,CAAC;EACb,CAAC,CAAC;;;;AAIH,KAAM,WAAW,GAAG,+BAAK,QAAQ,CAAC,CAAC;;AAEnC,KAAM,WAAW,GAAG,kCAAQ,8BAAI,WAAW,CAAC,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;;AAE/D,KAAM,0BAA0B,GAAG,gCAAM,UAAS,EAAE,EAAE,KAAK,EAAE;AACzD,SAAI,UAAU,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;AACrC,SAAI,oBAAoB,GAAG,8BAAI,kBAAkB,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;;AAE9D,YAAO,kCACH,KAAK,CAAC,UAAU,CAAC,EACjB,oDAAkB,EAClB,oBAAoB,CACvB,CAAC,KAAK,CAAC,CAAC;EACZ,CAAC,CAAC;;AAEH,KAAM,gCAAgC,GAAG,SAAnC,gCAAgC,CAAY,EAAE,EAAE;AAClD,YAAO,0BAA0B,CAAC,EAAE,EAAE,6BAAgB,CAAC,CAAC;EAC3D,CAAC;;;;AAIF,KAAI,EAAE,GAAG,QAAQ,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;;AAE9C,KAAI,OAAO,GAAG,6CAEV,gCAAgC,CACnC,CAAC;;AAEF,YAAW,CAAC,EAAE,CAAC,CAAC,OAAO,CACnB,OAAO,CACV,C;;;;;;ACjFD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,EAAC;;;;;;;AChDD;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;;;;;;;AClBA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACtDD;AACA;AACA;AACA,gCAA+B,kCAAkC;AACjE,kCAAiC,kCAAkC;AACnE,sCAAqC,kCAAkC;AACvE,0CAAyC,kCAAkC;AAC3E,8CAA6C,kCAAkC;AAC/E,kDAAiD,kCAAkC;AACnF,sDAAqD,kCAAkC;AACvF,0DAAyD,kCAAkC;AAC3F,8DAA6D,kCAAkC;AAC/F,kEAAiE,kCAAkC;AACnG,uEAAsE,kCAAkC;AACxG;AACA;AACA;;;;;;;AChBA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,mCAAkC,iBAAiB,EAAE;AACrD,MAAK;AACL;AACA;AACA,MAAK;AACL,mCAAkC,iBAAiB,EAAE;AACrD,MAAK;AACL,mCAAkC,iBAAiB,EAAE;AACrD,MAAK;AACL;AACA;AACA;AACA;;;;;;;AC/BA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,MAAM;AAClB,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrCA;AACA;AACA;AACA;;;AAGA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/BA;AACA;AACA;AACA;AACA;;;;;;;ACJA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA,YAAW,EAAE;AACb,YAAW,MAAM;AACjB,aAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;;;;;;;ACnCA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,sCAAqC,oBAAoB,EAAE;AAC3D,MAAK;AACL;AACA;AACA,MAAK;AACL,sCAAqC,oBAAoB,EAAE;AAC3D,MAAK;AACL,sCAAqC,oBAAoB,EAAE;AAC3D,MAAK;AACL,mCAAkC,oBAAoB,EAAE;AACxD,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA,sCAAqC,oBAAoB,EAAE;AAC3D,MAAK;AACL;AACA,sCAAqC,oBAAoB,EAAE;AAC3D,MAAK;AACL;AACA,sCAAqC,oBAAoB,EAAE;AAC3D,MAAK;AACL,mCAAkC,oBAAoB,EAAE;AACxD,MAAK;AACL,mCAAkC,oBAAoB,EAAE;AACxD,MAAK;AACL,mCAAkC,oBAAoB,EAAE;AACxD,MAAK;AACL;AACA;AACA;AACA;;;;;;;ACrDA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACvDD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA0D,YAAY;AACtE;AACA;AACA;;AAEA,+BAA8B,sBAAsB;AACpD,EAAC;;;;;;;ACbD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,EAAE;AACvB,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;;;;;;ACvBD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,aAAY,QAAQ,yEAAyE;AAC7F;AACA;AACA,2BAA0B;AAC1B,6BAA4B;AAC5B,yBAAwB,EAAE;AAC1B,wBAAuB,WAAW,EAAE;AACpC,wBAAuB,iCAAiC,EAAE;AAC1D;AACA;AACA,qBAAoB,aAAa;AACjC,YAAW,cAAc;AACzB,+BAA8B,cAAc;AAC5C,6BAA4B,cAAc;AAC1C,0BAAyB,mBAAmB;AAC5C,wBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACjCD;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,aAAY,QAAQ;AACpB;AACA;AACA,sBAAqB;AACrB,wBAAuB;AACvB,oBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;;;;;;;AChBA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,aAAY;AACZ;AACA;AACA,2BAA0B;AAC1B,wBAAuB;AACvB,qBAAoB;AACpB,oBAAmB;AACnB;AACA,uBAAsB;AACtB,sBAAqB;AACrB,qBAAoB;AACpB,oBAAmB;AACnB;AACA;;;;;;;AC5BA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzBA;AACA;AACA;AACA;AACA,YAAW,gBAAgB;AAC3B,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,MAAM;AAClB;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/BA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,EAAE;AACb,aAAY;AACZ;AACA;AACA,6CAA4C;AAC5C,oDAAmD;AACnD,8CAA6C;AAC7C,+CAA8C;AAC9C,gCAA+B;AAC/B;AACA;AACA;AACA,EAAC;;;;;;;AC3BD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,MAAM;AACjB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;;;;;;;AChCA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtCA;AACA;AACA;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACPA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAwC,wBAAwB,EAAE;AAClE,EAAC;;;;;;;AChBD;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;;;;;;ACPA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,UAAS;AACT,sCAAqC;AACrC;AACA;AACA;AACA,UAAS;AACT,gDAA+C;AAC/C;AACA;AACA;AACA,EAAC;;;;;;;AC7BD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,UAAS;AACT,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;;;;;;AC/BD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,aAAY,MAAM;AAClB;AACA;AACA,kDAAiD;AACjD;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;;;;;;ACzBD;AACA;AACA;AACA;AACA,YAAW,gBAAgB;AAC3B,YAAW,gBAAgB;AAC3B,aAAY,MAAM;AAClB;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9BA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;AACA,uBAAsB;AACtB,oCAAmC,kBAAkB;AACrD;AACA,qCAAoC;AACpC,mCAAkC;AAClC;AACA;AACA;AACA;;;;;;;ACtBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,EAAE;AACb,aAAY,EAAE;AACd;AACA;AACA,iCAAgC,0BAA0B;AAC1D,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACtBD;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,KAAK;AACnB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,EAAE;AACd;AACA;AACA,sBAAqB,OAAO,EAAE;AAC9B,uBAAsB,EAAE;AACxB;AACA,iDAAgD,eAAe,EAAE;;;;;;;AClBjE;AACA;;;AAGA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1BA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,aAAY,MAAM;AAClB;AACA;AACA,8BAA6B;AAC7B,2BAA0B;AAC1B,wBAAuB;AACvB,uBAAsB;AACtB;AACA;AACA;AACA,EAAC;;;;;;;ACvBD;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;;;;;;iEChCD;AACA;AACA,iBAAgB;AAChB,uCAAsC,0BAA0B,yDAAyD,EAAE,kBAAkB,0BAA0B,EAAE,mCAAmC,8BAA8B,oCAAoC,cAAc,EAAE;AAC9R;AACA,6BAA4B,mBAAmB,gCAAgC,GAAG;;AAElF;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,wCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,wCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,oCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,oCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,oCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,oCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,oCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,sBAAqB,GAAG;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,YAAW;AACX,oBAAmB,kBAAkB;AACrC,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL,2BAA0B;AAC1B;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,UAAU;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,UAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,UAAU;AAC7D;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,wDAAuD,UAAU;AACjE;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,2CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,QAAO;AACP;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA,4CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA8C,UAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAoC,UAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,uCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,0CAAyC,UAAU;AACnD;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2GAA0G;AAC1G;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,gBAAe;AACf;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,UAAU;AACnD;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;;AAEA,EAAC;;;;;;;;AC32GD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA,8BAA6B,mDAAmD;;;;;;;ACAhF;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yC;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,oBAAoB;AAC7D;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,mBAAmB;AAC3D;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAkE;AAClE;AACA,sBAAqB;AACrB;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA6E;AAC7E,sBAAqB;AACrB;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAiC,mBAAmB;AACpD;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,sBAAsB;AAC7D;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA6D;AAC7D,sBAAqB;AACrB;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAgE;AAChE,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA,+BAA8B,mCAAmC;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA4D;AAC5D,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAgE;AAChE,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA6D;AAC7D,sBAAqB;AACrB;;;;;;;ACzSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAkB,2BAA2B;AAC7C;;AAEA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA,0CAAyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,eAAe;AAClC;AACA,E;;;;;;;;;;;ACpFO,KAAM,KAAK,GAAG,SAAR,KAAK,CAAY,EAAE,EAAE;AAC9B,YAAO,EAAE,CAAC,GAAG,EAAE,CAAC;EACnB,CAAC;;;AAEK,KAAM,MAAM,GAAG,SAAT,MAAM,CAAY,EAAE,EAAE;AAC/B,SAAI,CAAC,GAAG,GAAG,EAAE,CAAC;AACd,SAAI,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC;EACzB,CAAC;;;AAEK,KAAM,EAAE,GAAG,SAAL,EAAE,CAAY,EAAE,EAAE;AAC3B,YAAQ,IAAI,MAAM,CAAC,EAAE,CAAC,CAAE;EAC3B,CAAC;;;AAEF,OAAM,CAAC,EAAE,GAAG,UAAS,CAAC,EAAE;AACpB,YAAO,EAAE,CAAC,YAAW;AACjB,gBAAO,CAAC,CAAC;MACZ,CAAC,CAAC;EACN,CAAC;AACF,OAAM,CAAC,SAAS,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC;;AAEhC,OAAM,CAAC,SAAS,CAAC,KAAK,GAAG,UAAS,CAAC,EAAE;AACjC,SAAI,EAAE,GAAG,IAAI,CAAC;AACd,YAAO,EAAE,CAAC,YAAW;AACjB,gBAAO,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC;MAC5B,CAAC,CAAC;EACN,CAAC;;;AAGF,OAAM,CAAC,SAAS,CAAC,GAAG,GAAG,UAAS,CAAC,EAAE;AAC/B,YAAO,IAAI,CAAC,KAAK,CAAC,UAAS,CAAC,EAAE;AAC1B,gBAAO,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAC1B,CAAC,CAAC;EACN,CAAC;AACF,OAAM,CAAC,SAAS,CAAC,EAAE,GAAG,UAAS,CAAC,EAAE;AAC9B,YAAO,IAAI,CAAC,KAAK,CAAC,UAAS,CAAC,EAAE;AAC1B,gBAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACnB,CAAC,CAAC;EACN,CAAC;;AAEK,KAAM,QAAQ,GAAG,SAAX,QAAQ,GAAc;AAC/B,aAAQ,CAAC,SAAS,CAAC,IAAI,GAAG,YAAW;AACjC,aAAI,IAAI,GAAG,IAAI,CAAC;AAChB,gBAAO,UAAS,CAAC,EAAE;AAAE,oBAAO,EAAE,CAAC,YAAW;AAAE,wBAAO,IAAI,CAAC,CAAC,CAAC;cAAE,CAAC,CAAC;UAAE,CAAC;MACpE,CAAC;EACL,CAAC;;;;;;;;;;;;;;;AC5CK,UAAS,cAAc,GAAG;AAC7B,SAAI,OAAO,GAAG,kBAAkB,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;AAC3C,SAAI,KAAK,GAAG,GAAG,CAAC;AAChB,UAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAG;AACzB,cAAK,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;MACpD;AACD,YAAO,KAAK,CAAC;EAChB;;AAEM,UAAS,aAAa,CAAC,QAAQ,EAAE;AACpC,YAAQ,MAAM,CAAC,QAAQ,CAAC,GAAG,QAAQ,GAAC,CAAC,GAAI,SAAS,GAAG,SAAS,CAAC;EAClE;;AAED,UAAS,MAAM,CAAC,UAAU,EAAE;;;;;;;;AAQxB,eAAU,GAAG,CAAC,UAAU,GAAG,EAAE,EACxB,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC;AAChC,YAAO,QAAQ,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e47f4c34504939bc76df\n **/","import curry from 'ramda/src/curry';\nimport pipe from 'ramda/src/pipe';\nimport map from 'ramda/src/map';\nimport lift from 'ramda/src/lift';\nimport tap from 'ramda/src/tap';\nimport prop from 'ramda/src/prop';\nimport compose from 'ramda/src/compose';\nimport flip from 'ramda/src/flip';\nimport Bacon from 'baconjs';\nimport Future from 'data.future';\nimport {IO, runIO, extendFn as extendFnIO} from 'io';\nimport {getRandomColor, contrastColor} from './colors';\n\nextendFnIO();\n\n// HELPERS\n\nconst listen = curry(function (event, target) {\n    return Bacon.fromEventTarget(target, event);\n});\n\nconst log = function(x) {\n    console.log(x);\n    return x;\n};\n\nconst fork = curry(function(f, future) {\n    return future.fork(log, f);\n});\n\nconst chain = curry(function(f, functor) {\n    return functor.chain(f);\n});\n\nconst setHtml = curry(function(el, x) {\n    el.innerHtml = x;\n    return el;\n});\n\nconst setBackgroundColor = curry(function(el, color) {\n    el.style.backgroundColor = color;\n    return el;\n});\n\nconst setColor = curry(function(el, color) {\n    el.style.color = color;\n    return el;\n});\n\n// PURE\n\nconst eventTarget = prop('target');\n\nconst clickStream = compose(map(eventTarget), listen('click'));\n\nconst setBgColorAndContrastColor = curry(function(el, color) {\n    let setColorEl = setColor(el).toIO();\n    let setBackgroundColorEl = tap(setBackgroundColor(el)).toIO();\n\n    return compose(\n        chain(setColorEl),\n        map(contrastColor),\n        setBackgroundColorEl\n    )(color);\n});\n\nconst setRandomBgColorAndContrastColor = function(el) {\n    return setBgColorAndContrastColor(el, getRandomColor());\n};\n\n// UNPURE\n\nlet el = document.getElementById('container');\n\nlet randCol = compose(\n    runIO,\n    setRandomBgColorAndContrastColor\n);\n\nclickStream(el).onValue(\n    randCol\n);\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./index.js\n **/","var _curry1 = require('./internal/_curry1');\nvar curryN = require('./curryN');\n\n\n/**\n * Returns a curried equivalent of the provided function. The curried\n * function has two unusual capabilities. First, its arguments needn't\n * be provided one at a time. If `f` is a ternary function and `g` is\n * `R.curry(f)`, the following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value `R.__` may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is `R.__`,\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @category Function\n * @sig (* -> a) -> (* -> a)\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curryN\n * @example\n *\n *      var addFourNumbers = function(a, b, c, d) {\n *        return a + b + c + d;\n *      };\n *\n *      var curriedAddFourNumbers = R.curry(addFourNumbers);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\nmodule.exports = _curry1(function curry(fn) {\n  return curryN(fn.length, fn);\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/curry.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0) {\n      return f1;\n    } else if (a != null && a['@@functional/placeholder'] === true) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_curry1.js\n ** module id = 2\n ** module chunks = 0\n **/","var _arity = require('./internal/_arity');\nvar _curry1 = require('./internal/_curry1');\nvar _curry2 = require('./internal/_curry2');\nvar _curryN = require('./internal/_curryN');\n\n\n/**\n * Returns a curried equivalent of the provided function, with the\n * specified arity. The curried function has two unusual capabilities.\n * First, its arguments needn't be provided one at a time. If `g` is\n * `R.curryN(3, f)`, the following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value `R.__` may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is `R.__`,\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      var addFourNumbers = function() {\n *        return R.sum([].slice.call(arguments, 0, 4));\n *      };\n *\n *      var curriedAddFourNumbers = R.curryN(4, addFourNumbers);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\nmodule.exports = _curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/curryN.js\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = function _arity(n, fn) {\n  // jshint unused:vars\n  switch (n) {\n    case 0: return function() { return fn.apply(this, arguments); };\n    case 1: return function(a0) { return fn.apply(this, arguments); };\n    case 2: return function(a0, a1) { return fn.apply(this, arguments); };\n    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };\n    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };\n    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };\n    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };\n    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };\n    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };\n    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };\n    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };\n    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_arity.js\n ** module id = 4\n ** module chunks = 0\n **/","var _curry1 = require('./_curry1');\n\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry2(fn) {\n  return function f2(a, b) {\n    var n = arguments.length;\n    if (n === 0) {\n      return f2;\n    } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {\n      return f2;\n    } else if (n === 1) {\n      return _curry1(function(b) { return fn(a, b); });\n    } else if (n === 2 && a != null && a['@@functional/placeholder'] === true &&\n                          b != null && b['@@functional/placeholder'] === true) {\n      return f2;\n    } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {\n      return _curry1(function(a) { return fn(a, b); });\n    } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {\n      return _curry1(function(b) { return fn(a, b); });\n    } else {\n      return fn(a, b);\n    }\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_curry2.js\n ** module id = 5\n ** module chunks = 0\n **/","var _arity = require('./_arity');\n\n\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @return {array} An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n */\nmodule.exports = function _curryN(length, received, fn) {\n  return function() {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n      if (combinedIdx < received.length &&\n          (received[combinedIdx] == null ||\n           received[combinedIdx]['@@functional/placeholder'] !== true ||\n           argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result;\n      if (result == null || result['@@functional/placeholder'] !== true) {\n        left -= 1;\n      }\n      combinedIdx += 1;\n    }\n    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_curryN.js\n ** module id = 6\n ** module chunks = 0\n **/","var _pipe = require('./internal/_pipe');\nvar curryN = require('./curryN');\nvar reduce = require('./reduce');\nvar tail = require('./tail');\n\n\n/**\n * Performs left-to-right function composition. The leftmost function may have\n * any arity; the remaining functions must be unary.\n *\n * In some libraries this function is named `sequence`.\n *\n * @func\n * @memberOf R\n * @category Function\n * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> (a -> b -> ... -> n -> z)\n * @param {...Function} functions\n * @return {Function}\n * @see R.compose\n * @example\n *\n *      var f = R.pipe(Math.pow, R.negate, R.inc);\n *\n *      f(3, 4); // -(3^4) + 1\n */\nmodule.exports = function pipe() {\n  if (arguments.length === 0) {\n    throw new Error('pipe requires at least one argument');\n  }\n  return curryN(arguments[0].length,\n                reduce(_pipe, arguments[0], tail(arguments)));\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/pipe.js\n ** module id = 7\n ** module chunks = 0\n **/","module.exports = function _pipe(f, g) {\n  return function() {\n    return g.call(this, f.apply(this, arguments));\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_pipe.js\n ** module id = 8\n ** module chunks = 0\n **/","var _curry3 = require('./internal/_curry3');\nvar _reduce = require('./internal/_reduce');\n\n\n/**\n * Returns a single item by iterating through the list, successively calling the iterator\n * function and passing it an accumulator value and the current value from the array, and\n * then passing the result to the next call.\n *\n * The iterator function receives two values: *(acc, value)*.  It may use `R.reduced` to\n * shortcut the iteration.\n *\n * Note: `R.reduce` does not skip deleted or unassigned indices (sparse arrays), unlike\n * the native `Array.prototype.reduce` method. For more details on this behavior, see:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\n * @see R.reduced\n *\n * @func\n * @memberOf R\n * @category List\n * @sig (a,b -> a) -> a -> [b] -> a\n * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n *        current element from the array.\n * @param {*} acc The accumulator value.\n * @param {Array} list The list to iterate over.\n * @return {*} The final, accumulated value.\n * @example\n *\n *      var numbers = [1, 2, 3];\n *      var add = function(a, b) {\n *        return a + b;\n *      };\n *\n *      R.reduce(add, 10, numbers); //=> 16\n */\nmodule.exports = _curry3(_reduce);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/reduce.js\n ** module id = 9\n ** module chunks = 0\n **/","var _curry1 = require('./_curry1');\nvar _curry2 = require('./_curry2');\n\n\n/**\n * Optimized internal three-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry3(fn) {\n  return function f3(a, b, c) {\n    var n = arguments.length;\n    if (n === 0) {\n      return f3;\n    } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {\n      return f3;\n    } else if (n === 1) {\n      return _curry2(function(b, c) { return fn(a, b, c); });\n    } else if (n === 2 && a != null && a['@@functional/placeholder'] === true &&\n                          b != null && b['@@functional/placeholder'] === true) {\n      return f3;\n    } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {\n      return _curry2(function(a, c) { return fn(a, b, c); });\n    } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {\n      return _curry2(function(b, c) { return fn(a, b, c); });\n    } else if (n === 2) {\n      return _curry1(function(c) { return fn(a, b, c); });\n    } else if (n === 3 && a != null && a['@@functional/placeholder'] === true &&\n                          b != null && b['@@functional/placeholder'] === true &&\n                          c != null && c['@@functional/placeholder'] === true) {\n      return f3;\n    } else if (n === 3 && a != null && a['@@functional/placeholder'] === true &&\n                          b != null && b['@@functional/placeholder'] === true) {\n      return _curry2(function(a, b) { return fn(a, b, c); });\n    } else if (n === 3 && a != null && a['@@functional/placeholder'] === true &&\n                          c != null && c['@@functional/placeholder'] === true) {\n      return _curry2(function(a, c) { return fn(a, b, c); });\n    } else if (n === 3 && b != null && b['@@functional/placeholder'] === true &&\n                          c != null && c['@@functional/placeholder'] === true) {\n      return _curry2(function(b, c) { return fn(a, b, c); });\n    } else if (n === 3 && a != null && a['@@functional/placeholder'] === true) {\n      return _curry1(function(a) { return fn(a, b, c); });\n    } else if (n === 3 && b != null && b['@@functional/placeholder'] === true) {\n      return _curry1(function(b) { return fn(a, b, c); });\n    } else if (n === 3 && c != null && c['@@functional/placeholder'] === true) {\n      return _curry1(function(c) { return fn(a, b, c); });\n    } else {\n      return fn(a, b, c);\n    }\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_curry3.js\n ** module id = 10\n ** module chunks = 0\n **/","var _xwrap = require('./_xwrap');\nvar bind = require('../bind');\nvar isArrayLike = require('../isArrayLike');\n\n\nmodule.exports = (function() {\n  function _arrayReduce(xf, acc, list) {\n    var idx = 0, len = list.length;\n    while (idx < len) {\n      acc = xf['@@transducer/step'](acc, list[idx]);\n      if (acc && acc['@@transducer/reduced']) {\n        acc = acc['@@transducer/value'];\n        break;\n      }\n      idx += 1;\n    }\n    return xf['@@transducer/result'](acc);\n  }\n\n  function _iterableReduce(xf, acc, iter) {\n    var step = iter.next();\n    while (!step.done) {\n      acc = xf['@@transducer/step'](acc, step.value);\n      if (acc && acc['@@transducer/reduced']) {\n        acc = acc['@@transducer/value'];\n        break;\n      }\n      step = iter.next();\n    }\n    return xf['@@transducer/result'](acc);\n  }\n\n  function _methodReduce(xf, acc, obj) {\n    return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));\n  }\n\n  var symIterator = (typeof Symbol !== 'undefined') ? Symbol.iterator : '@@iterator';\n  return function _reduce(fn, acc, list) {\n    if (typeof fn === 'function') {\n      fn = _xwrap(fn);\n    }\n    if (isArrayLike(list)) {\n      return _arrayReduce(fn, acc, list);\n    }\n    if (typeof list.reduce === 'function') {\n      return _methodReduce(fn, acc, list);\n    }\n    if (list[symIterator] != null) {\n      return _iterableReduce(fn, acc, list[symIterator]());\n    }\n    if (typeof list.next === 'function') {\n      return _iterableReduce(fn, acc, list);\n    }\n    throw new TypeError('reduce: list must be array or iterable');\n  };\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_reduce.js\n ** module id = 11\n ** module chunks = 0\n **/","module.exports = (function() {\n  function XWrap(fn) {\n    this.f = fn;\n  }\n  XWrap.prototype['@@transducer/init'] = function() {\n    throw new Error('init not implemented on XWrap');\n  };\n  XWrap.prototype['@@transducer/result'] = function(acc) { return acc; };\n  XWrap.prototype['@@transducer/step'] = function(acc, x) {\n    return this.f(acc, x);\n  };\n\n  return function _xwrap(fn) { return new XWrap(fn); };\n}());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_xwrap.js\n ** module id = 12\n ** module chunks = 0\n **/","var _arity = require('./internal/_arity');\nvar _curry2 = require('./internal/_curry2');\n\n\n/**\n * Creates a function that is bound to a context.\n * Note: `R.bind` does not provide the additional argument-binding capabilities of\n * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n *\n * @func\n * @memberOf R\n * @category Function\n * @category Object\n * @see R.partial\n * @sig (* -> *) -> {*} -> (* -> *)\n * @param {Function} fn The function to bind to context\n * @param {Object} thisObj The context to bind `fn` to\n * @return {Function} A function that will execute in the context of `thisObj`.\n */\nmodule.exports = _curry2(function bind(fn, thisObj) {\n  return _arity(fn.length, function() {\n    return fn.apply(thisObj, arguments);\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/bind.js\n ** module id = 13\n ** module chunks = 0\n **/","var _curry1 = require('./internal/_curry1');\nvar _isArray = require('./internal/_isArray');\n\n\n/**\n * Tests whether or not an object is similar to an array.\n *\n * @func\n * @memberOf R\n * @category Type\n * @category List\n * @sig * -> Boolean\n * @param {*} x The object to test.\n * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.\n * @example\n *\n *      R.isArrayLike([]); //=> true\n *      R.isArrayLike(true); //=> false\n *      R.isArrayLike({}); //=> false\n *      R.isArrayLike({length: 10}); //=> false\n *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true\n */\nmodule.exports = _curry1(function isArrayLike(x) {\n  if (_isArray(x)) { return true; }\n  if (!x) { return false; }\n  if (typeof x !== 'object') { return false; }\n  if (x instanceof String) { return false; }\n  if (x.nodeType === 1) { return !!x.length; }\n  if (x.length === 0) { return true; }\n  if (x.length > 0) {\n    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);\n  }\n  return false;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/isArrayLike.js\n ** module id = 14\n ** module chunks = 0\n **/","/**\n * Tests whether or not an object is an array.\n *\n * @private\n * @param {*} val The object to test.\n * @return {Boolean} `true` if `val` is an array, `false` otherwise.\n * @example\n *\n *      _isArray([]); //=> true\n *      _isArray(null); //=> false\n *      _isArray({}); //=> false\n */\nmodule.exports = Array.isArray || function _isArray(val) {\n  return (val != null &&\n          val.length >= 0 &&\n          Object.prototype.toString.call(val) === '[object Array]');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_isArray.js\n ** module id = 15\n ** module chunks = 0\n **/","var _checkForMethod = require('./internal/_checkForMethod');\nvar slice = require('./slice');\n\n\n/**\n * Returns all but the first element of the given list or string (or object\n * with a `tail` method).\n *\n * @func\n * @memberOf R\n * @category List\n * @see R.head, R.init, R.last\n * @sig [a] -> [a]\n * @sig String -> String\n * @param {*} list\n * @return {*}\n * @example\n *\n *      R.tail([1, 2, 3]);  //=> [2, 3]\n *      R.tail([1, 2]);     //=> [2]\n *      R.tail([1]);        //=> []\n *      R.tail([]);         //=> []\n *\n *      R.tail('abc');  //=> 'bc'\n *      R.tail('ab');   //=> 'b'\n *      R.tail('a');    //=> ''\n *      R.tail('');     //=> ''\n */\nmodule.exports = _checkForMethod('tail', slice(1, Infinity));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/tail.js\n ** module id = 16\n ** module chunks = 0\n **/","var _isArray = require('./_isArray');\nvar _slice = require('./_slice');\n\n\n/**\n * Similar to hasMethod, this checks whether a function has a [methodname]\n * function. If it isn't an array it will execute that function otherwise it will\n * default to the ramda implementation.\n *\n * @private\n * @param {Function} fn ramda implemtation\n * @param {String} methodname property to check for a custom implementation\n * @return {Object} Whatever the return value of the method is.\n */\nmodule.exports = function _checkForMethod(methodname, fn) {\n  return function() {\n    var length = arguments.length;\n    if (length === 0) {\n      return fn();\n    }\n    var obj = arguments[length - 1];\n    return (_isArray(obj) || typeof obj[methodname] !== 'function') ?\n      fn.apply(this, arguments) :\n      obj[methodname].apply(obj, _slice(arguments, 0, length - 1));\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_checkForMethod.js\n ** module id = 17\n ** module chunks = 0\n **/","/**\n * An optimized, private array `slice` implementation.\n *\n * @private\n * @param {Arguments|Array} args The array or arguments object to consider.\n * @param {Number} [from=0] The array index to slice from, inclusive.\n * @param {Number} [to=args.length] The array index to slice to, exclusive.\n * @return {Array} A new, sliced array.\n * @example\n *\n *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]\n *\n *      var firstThreeArgs = function(a, b, c, d) {\n *        return _slice(arguments, 0, 3);\n *      };\n *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]\n */\nmodule.exports = function _slice(args, from, to) {\n  switch (arguments.length) {\n    case 1: return _slice(args, 0, args.length);\n    case 2: return _slice(args, from, args.length);\n    default:\n      var list = [];\n      var idx = 0;\n      var len = Math.max(0, Math.min(args.length, to) - from);\n      while (idx < len) {\n        list[idx] = args[from + idx];\n        idx += 1;\n      }\n      return list;\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_slice.js\n ** module id = 18\n ** module chunks = 0\n **/","var _checkForMethod = require('./internal/_checkForMethod');\nvar _curry3 = require('./internal/_curry3');\n\n\n/**\n * Returns the elements of the given list or string (or object with a `slice`\n * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).\n *\n * @func\n * @memberOf R\n * @category List\n * @sig Number -> Number -> [a] -> [a]\n * @sig Number -> Number -> String -> String\n * @param {Number} fromIndex The start index (inclusive).\n * @param {Number} toIndex The end index (exclusive).\n * @param {*} list\n * @return {*}\n * @example\n *\n *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']\n *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']\n *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']\n *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']\n *      R.slice(0, 3, 'ramda');                     //=> 'ram'\n */\nmodule.exports = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {\n  return Array.prototype.slice.call(list, fromIndex, toIndex);\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/slice.js\n ** module id = 19\n ** module chunks = 0\n **/","var _curry2 = require('./internal/_curry2');\nvar _dispatchable = require('./internal/_dispatchable');\nvar _map = require('./internal/_map');\nvar _xmap = require('./internal/_xmap');\n\n\n/**\n * Returns a new list, constructed by applying the supplied function to every element of the\n * supplied list.\n *\n * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays), unlike the\n * native `Array.prototype.map` method. For more details on this behavior, see:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description\n *\n * Acts as a transducer if a transformer is given in list position.\n * @see R.transduce\n *\n * @func\n * @memberOf R\n * @category List\n * @sig (a -> b) -> [a] -> [b]\n * @param {Function} fn The function to be called on every element of the input `list`.\n * @param {Array} list The list to be iterated over.\n * @return {Array} The new list.\n * @example\n *\n *      var double = function(x) {\n *        return x * 2;\n *      };\n *\n *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]\n */\nmodule.exports = _curry2(_dispatchable('map', _xmap, _map));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/map.js\n ** module id = 20\n ** module chunks = 0\n **/","var _isArray = require('./_isArray');\nvar _isTransformer = require('./_isTransformer');\nvar _slice = require('./_slice');\n\n\n/**\n * Returns a function that dispatches with different strategies based on the\n * object in list position (last argument). If it is an array, executes [fn].\n * Otherwise, if it has a  function with [methodname], it will execute that\n * function (functor case). Otherwise, if it is a transformer, uses transducer\n * [xf] to return a new transformer (transducer case). Otherwise, it will\n * default to executing [fn].\n *\n * @private\n * @param {String} methodname property to check for a custom implementation\n * @param {Function} xf transducer to initialize if object is transformer\n * @param {Function} fn default ramda implementation\n * @return {Function} A function that dispatches on object in list position\n */\nmodule.exports = function _dispatchable(methodname, xf, fn) {\n  return function() {\n    var length = arguments.length;\n    if (length === 0) {\n      return fn();\n    }\n    var obj = arguments[length - 1];\n    if (!_isArray(obj)) {\n      var args = _slice(arguments, 0, length - 1);\n      if (typeof obj[methodname] === 'function') {\n        return obj[methodname].apply(obj, args);\n      }\n      if (_isTransformer(obj)) {\n        var transducer = xf.apply(null, args);\n        return transducer(obj);\n      }\n    }\n    return fn.apply(this, arguments);\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_dispatchable.js\n ** module id = 21\n ** module chunks = 0\n **/","module.exports = function _isTransformer(obj) {\n  return typeof obj['@@transducer/step'] === 'function';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_isTransformer.js\n ** module id = 22\n ** module chunks = 0\n **/","module.exports = function _map(fn, list) {\n  var idx = 0, len = list.length, result = Array(len);\n  while (idx < len) {\n    result[idx] = fn(list[idx]);\n    idx += 1;\n  }\n  return result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_map.js\n ** module id = 23\n ** module chunks = 0\n **/","var _curry2 = require('./_curry2');\nvar _xfBase = require('./_xfBase');\n\n\nmodule.exports = (function() {\n  function XMap(f, xf) {\n    this.xf = xf;\n    this.f = f;\n  }\n  XMap.prototype['@@transducer/init'] = _xfBase.init;\n  XMap.prototype['@@transducer/result'] = _xfBase.result;\n  XMap.prototype['@@transducer/step'] = function(result, input) {\n    return this.xf['@@transducer/step'](result, this.f(input));\n  };\n\n  return _curry2(function _xmap(f, xf) { return new XMap(f, xf); });\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_xmap.js\n ** module id = 24\n ** module chunks = 0\n **/","module.exports = {\n  init: function() {\n    return this.xf['@@transducer/init']();\n  },\n  result: function(result) {\n    return this.xf['@@transducer/result'](result);\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_xfBase.js\n ** module id = 25\n ** module chunks = 0\n **/","var _curry1 = require('./internal/_curry1');\nvar liftN = require('./liftN');\n\n\n/**\n * \"lifts\" a function of arity > 1 so that it may \"map over\" an Array or\n * other Functor.\n *\n * @func\n * @memberOf R\n * @see R.liftN\n * @category Function\n * @sig (*... -> *) -> ([*]... -> [*])\n * @param {Function} fn The function to lift into higher context\n * @return {Function} The function `fn` applicable to mappable objects.\n * @example\n *\n *      var madd3 = R.lift(R.curry(function(a, b, c) {\n *        return a + b + c;\n *      }));\n *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n *\n *      var madd5 = R.lift(R.curry(function(a, b, c, d, e) {\n *        return a + b + c + d + e;\n *      }));\n *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]\n */\nmodule.exports = _curry1(function lift(fn) {\n  return liftN(fn.length, fn);\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/lift.js\n ** module id = 26\n ** module chunks = 0\n **/","var _curry2 = require('./internal/_curry2');\nvar _reduce = require('./internal/_reduce');\nvar _slice = require('./internal/_slice');\nvar ap = require('./ap');\nvar curryN = require('./curryN');\nvar map = require('./map');\n\n\n/**\n * \"lifts\" a function to be the specified arity, so that it may \"map over\" that many\n * lists (or other Functors).\n *\n * @func\n * @memberOf R\n * @see R.lift\n * @category Function\n * @sig Number -> (*... -> *) -> ([*]... -> [*])\n * @param {Function} fn The function to lift into higher context\n * @return {Function} The function `fn` applicable to mappable objects.\n * @example\n *\n *      var madd3 = R.liftN(3, R.curryN(3, function() {\n *        return R.reduce(R.add, 0, arguments);\n *      }));\n *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n */\nmodule.exports = _curry2(function liftN(arity, fn) {\n  var lifted = curryN(arity, fn);\n  return curryN(arity, function() {\n    return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/liftN.js\n ** module id = 27\n ** module chunks = 0\n **/","var _concat = require('./internal/_concat');\nvar _curry2 = require('./internal/_curry2');\nvar _hasMethod = require('./internal/_hasMethod');\nvar _reduce = require('./internal/_reduce');\nvar map = require('./map');\n\n\n/**\n * ap applies a list of functions to a list of values.\n *\n * @func\n * @memberOf R\n * @category Function\n * @sig [f] -> [a] -> [f a]\n * @param {Array} fns An array of functions\n * @param {Array} vs An array of values\n * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.\n * @example\n *\n *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]\n */\nmodule.exports = _curry2(function ap(fns, vs) {\n  return _hasMethod('ap', fns) ? fns.ap(vs) : _reduce(function(acc, fn) {\n    return _concat(acc, map(fn, vs));\n  }, [], fns);\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/ap.js\n ** module id = 28\n ** module chunks = 0\n **/","/**\n * Private `concat` function to merge two array-like objects.\n *\n * @private\n * @param {Array|Arguments} [set1=[]] An array-like object.\n * @param {Array|Arguments} [set2=[]] An array-like object.\n * @return {Array} A new, merged array.\n * @example\n *\n *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]\n */\nmodule.exports = function _concat(set1, set2) {\n  set1 = set1 || [];\n  set2 = set2 || [];\n  var idx;\n  var len1 = set1.length;\n  var len2 = set2.length;\n  var result = [];\n\n  idx = 0;\n  while (idx < len1) {\n    result[result.length] = set1[idx];\n    idx += 1;\n  }\n  idx = 0;\n  while (idx < len2) {\n    result[result.length] = set2[idx];\n    idx += 1;\n  }\n  return result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_concat.js\n ** module id = 29\n ** module chunks = 0\n **/","var _isArray = require('./_isArray');\n\n\n/**\n * Private function that determines whether or not a provided object has a given method.\n * Does not ignore methods stored on the object's prototype chain. Used for dynamically\n * dispatching Ramda methods to non-Array objects.\n *\n * @private\n * @param {String} methodName The name of the method to check for.\n * @param {Object} obj The object to test.\n * @return {Boolean} `true` has a given method, `false` otherwise.\n * @example\n *\n *      var person = { name: 'John' };\n *      person.shout = function() { alert(this.name); };\n *\n *      _hasMethod('shout', person); //=> true\n *      _hasMethod('foo', person); //=> false\n */\nmodule.exports = function _hasMethod(methodName, obj) {\n  return obj != null && !_isArray(obj) && typeof obj[methodName] === 'function';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/internal/_hasMethod.js\n ** module id = 30\n ** module chunks = 0\n **/","var _curry2 = require('./internal/_curry2');\n\n\n/**\n * Runs the given function with the supplied object, then returns the object.\n *\n * @func\n * @memberOf R\n * @category Function\n * @sig (a -> *) -> a -> a\n * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.\n * @param {*} x\n * @return {*} `x`.\n * @example\n *\n *      var sayX = function(x) { console.log('x is ' + x); };\n *      R.tap(sayX, 100); //=> 100\n *      //-> 'x is 100'\n */\nmodule.exports = _curry2(function tap(fn, x) {\n  fn(x);\n  return x;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/tap.js\n ** module id = 31\n ** module chunks = 0\n **/","var _curry2 = require('./internal/_curry2');\n\n\n/**\n * Returns a function that when supplied an object returns the indicated property of that object, if it exists.\n *\n * @func\n * @memberOf R\n * @category Object\n * @sig s -> {s: a} -> a | Undefined\n * @param {String} p The property name\n * @param {Object} obj The object to query\n * @return {*} The value at `obj.p`.\n * @example\n *\n *      R.prop('x', {x: 100}); //=> 100\n *      R.prop('x', {}); //=> undefined\n */\nmodule.exports = _curry2(function prop(p, obj) { return obj[p]; });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/prop.js\n ** module id = 32\n ** module chunks = 0\n **/","var pipe = require('./pipe');\nvar reverse = require('./reverse');\n\n\n/**\n * Performs right-to-left function composition. The rightmost function may have\n * any arity; the remaining functions must be unary.\n *\n * @func\n * @memberOf R\n * @category Function\n * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> (a -> b -> ... -> n -> z)\n * @param {...Function} functions\n * @return {Function}\n * @see R.pipe\n * @example\n *\n *      var f = R.compose(R.inc, R.negate, Math.pow);\n *\n *      f(3, 4); // -(3^4) + 1\n */\nmodule.exports = function compose() {\n  if (arguments.length === 0) {\n    throw new Error('compose requires at least one argument');\n  }\n  return pipe.apply(this, reverse(arguments));\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/compose.js\n ** module id = 33\n ** module chunks = 0\n **/","var _curry1 = require('./internal/_curry1');\nvar _slice = require('./internal/_slice');\n\n\n/**\n * Returns a new list with the same elements as the original list, just\n * in the reverse order.\n *\n * @func\n * @memberOf R\n * @category List\n * @sig [a] -> [a]\n * @param {Array} list The list to reverse.\n * @return {Array} A copy of the list in reverse order.\n * @example\n *\n *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]\n *      R.reverse([1, 2]);     //=> [2, 1]\n *      R.reverse([1]);        //=> [1]\n *      R.reverse([]);         //=> []\n */\nmodule.exports = _curry1(function reverse(list) {\n  return _slice(list).reverse();\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/reverse.js\n ** module id = 34\n ** module chunks = 0\n **/","var _curry1 = require('./internal/_curry1');\nvar _slice = require('./internal/_slice');\nvar curry = require('./curry');\n\n\n/**\n * Returns a new function much like the supplied one, except that the first two arguments'\n * order is reversed.\n *\n * @func\n * @memberOf R\n * @category Function\n * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)\n * @param {Function} fn The function to invoke with its first two parameters reversed.\n * @return {*} The result of invoking `fn` with its first two parameters' order reversed.\n * @example\n *\n *      var mergeThree = function(a, b, c) {\n *        return ([]).concat(a, b, c);\n *      };\n *\n *      mergeThree(1, 2, 3); //=> [1, 2, 3]\n *\n *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]\n */\nmodule.exports = _curry1(function flip(fn) {\n  return curry(function(a, b) {\n    var args = _slice(arguments);\n    args[0] = b;\n    args[1] = a;\n    return fn.apply(this, args);\n  });\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ramda/src/flip.js\n ** module id = 35\n ** module chunks = 0\n **/","(function() {\n  var Bacon, BufferingSource, Bus, CompositeUnsubscribe, ConsumingSource, Desc, Dispatcher, End, Error, Event, EventStream, Exception, Initial, Next, None, Observable, Property, PropertyDispatcher, Some, Source, UpdateBarrier, _, addPropertyInitValueToStream, argumentsToObservables, argumentsToObservablesAndFunction, assert, assertArray, assertEventStream, assertFunction, assertNoArguments, assertObservable, assertObservableIsProperty, assertString, cloneArray, constantToFunction, containsDuplicateDeps, convertArgsToFunction, describe, endEvent, eventIdCounter, eventMethods, findDeps, findHandlerMethods, flatMap_, former, idCounter, initialEvent, isArray, isFieldKey, isObservable, latter, liftCallback, makeFunction, makeFunctionArgs, makeFunction_, makeObservable, makeSpawner, nextEvent, nop, partiallyApplied, recursionDepth, ref, registerObs, spys, toCombinator, toEvent, toFieldExtractor, toFieldKey, toOption, toSimpleExtractor, valueAndEnd, withDesc, withMethodCallSupport,\n    hasProp = {}.hasOwnProperty,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    slice = [].slice,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  Bacon = {\n    toString: function() {\n      return \"Bacon\";\n    }\n  };\n\n  Bacon.version = '0.7.71';\n\n  Exception = (typeof global !== \"undefined\" && global !== null ? global : this).Error;\n\n  nop = function() {};\n\n  latter = function(_, x) {\n    return x;\n  };\n\n  former = function(x, _) {\n    return x;\n  };\n\n  cloneArray = function(xs) {\n    return xs.slice(0);\n  };\n\n  assert = function(message, condition) {\n    if (!condition) {\n      throw new Exception(message);\n    }\n  };\n\n  assertObservableIsProperty = function(x) {\n    if (x instanceof Observable && !(x instanceof Property)) {\n      throw new Exception(\"Observable is not a Property : \" + x);\n    }\n  };\n\n  assertEventStream = function(event) {\n    if (!(event instanceof EventStream)) {\n      throw new Exception(\"not an EventStream : \" + event);\n    }\n  };\n\n  assertObservable = function(event) {\n    if (!(event instanceof Observable)) {\n      throw new Exception(\"not an Observable : \" + event);\n    }\n  };\n\n  assertFunction = function(f) {\n    return assert(\"not a function : \" + f, _.isFunction(f));\n  };\n\n  isArray = function(xs) {\n    return xs instanceof Array;\n  };\n\n  isObservable = function(x) {\n    return x instanceof Observable;\n  };\n\n  assertArray = function(xs) {\n    if (!isArray(xs)) {\n      throw new Exception(\"not an array : \" + xs);\n    }\n  };\n\n  assertNoArguments = function(args) {\n    return assert(\"no arguments supported\", args.length === 0);\n  };\n\n  assertString = function(x) {\n    if (typeof x !== \"string\") {\n      throw new Exception(\"not a string : \" + x);\n    }\n  };\n\n  _ = {\n    indexOf: Array.prototype.indexOf ? function(xs, x) {\n      return xs.indexOf(x);\n    } : function(xs, x) {\n      var i, j, len1, y;\n      for (i = j = 0, len1 = xs.length; j < len1; i = ++j) {\n        y = xs[i];\n        if (x === y) {\n          return i;\n        }\n      }\n      return -1;\n    },\n    indexWhere: function(xs, f) {\n      var i, j, len1, y;\n      for (i = j = 0, len1 = xs.length; j < len1; i = ++j) {\n        y = xs[i];\n        if (f(y)) {\n          return i;\n        }\n      }\n      return -1;\n    },\n    head: function(xs) {\n      return xs[0];\n    },\n    always: function(x) {\n      return function() {\n        return x;\n      };\n    },\n    negate: function(f) {\n      return function(x) {\n        return !f(x);\n      };\n    },\n    empty: function(xs) {\n      return xs.length === 0;\n    },\n    tail: function(xs) {\n      return xs.slice(1, xs.length);\n    },\n    filter: function(f, xs) {\n      var filtered, j, len1, x;\n      filtered = [];\n      for (j = 0, len1 = xs.length; j < len1; j++) {\n        x = xs[j];\n        if (f(x)) {\n          filtered.push(x);\n        }\n      }\n      return filtered;\n    },\n    map: function(f, xs) {\n      var j, len1, results, x;\n      results = [];\n      for (j = 0, len1 = xs.length; j < len1; j++) {\n        x = xs[j];\n        results.push(f(x));\n      }\n      return results;\n    },\n    each: function(xs, f) {\n      var key, value;\n      for (key in xs) {\n        if (!hasProp.call(xs, key)) continue;\n        value = xs[key];\n        f(key, value);\n      }\n      return void 0;\n    },\n    toArray: function(xs) {\n      if (isArray(xs)) {\n        return xs;\n      } else {\n        return [xs];\n      }\n    },\n    contains: function(xs, x) {\n      return _.indexOf(xs, x) !== -1;\n    },\n    id: function(x) {\n      return x;\n    },\n    last: function(xs) {\n      return xs[xs.length - 1];\n    },\n    all: function(xs, f) {\n      var j, len1, x;\n      if (f == null) {\n        f = _.id;\n      }\n      for (j = 0, len1 = xs.length; j < len1; j++) {\n        x = xs[j];\n        if (!f(x)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    any: function(xs, f) {\n      var j, len1, x;\n      if (f == null) {\n        f = _.id;\n      }\n      for (j = 0, len1 = xs.length; j < len1; j++) {\n        x = xs[j];\n        if (f(x)) {\n          return true;\n        }\n      }\n      return false;\n    },\n    without: function(x, xs) {\n      return _.filter((function(y) {\n        return y !== x;\n      }), xs);\n    },\n    remove: function(x, xs) {\n      var i;\n      i = _.indexOf(xs, x);\n      if (i >= 0) {\n        return xs.splice(i, 1);\n      }\n    },\n    fold: function(xs, seed, f) {\n      var j, len1, x;\n      for (j = 0, len1 = xs.length; j < len1; j++) {\n        x = xs[j];\n        seed = f(seed, x);\n      }\n      return seed;\n    },\n    flatMap: function(f, xs) {\n      return _.fold(xs, [], (function(ys, x) {\n        return ys.concat(f(x));\n      }));\n    },\n    cached: function(f) {\n      var value;\n      value = None;\n      return function() {\n        if (value === None) {\n          value = f();\n          f = void 0;\n        }\n        return value;\n      };\n    },\n    isFunction: function(f) {\n      return typeof f === \"function\";\n    },\n    toString: function(obj) {\n      var ex, internals, key, value;\n      try {\n        recursionDepth++;\n        if (obj == null) {\n          return \"undefined\";\n        } else if (_.isFunction(obj)) {\n          return \"function\";\n        } else if (isArray(obj)) {\n          if (recursionDepth > 5) {\n            return \"[..]\";\n          }\n          return \"[\" + _.map(_.toString, obj).toString() + \"]\";\n        } else if (((obj != null ? obj.toString : void 0) != null) && obj.toString !== Object.prototype.toString) {\n          return obj.toString();\n        } else if (typeof obj === \"object\") {\n          if (recursionDepth > 5) {\n            return \"{..}\";\n          }\n          internals = (function() {\n            var results;\n            results = [];\n            for (key in obj) {\n              if (!hasProp.call(obj, key)) continue;\n              value = (function() {\n                try {\n                  return obj[key];\n                } catch (_error) {\n                  ex = _error;\n                  return ex;\n                }\n              })();\n              results.push(_.toString(key) + \":\" + _.toString(value));\n            }\n            return results;\n          })();\n          return \"{\" + internals + \"}\";\n        } else {\n          return obj;\n        }\n      } finally {\n        recursionDepth--;\n      }\n    }\n  };\n\n  recursionDepth = 0;\n\n  Bacon._ = _;\n\n  UpdateBarrier = Bacon.UpdateBarrier = (function() {\n    var afterTransaction, afters, aftersIndex, currentEventId, flush, flushDepsOf, flushWaiters, hasWaiters, inTransaction, rootEvent, waiterObs, waiters, whenDoneWith, wrappedSubscribe;\n    rootEvent = void 0;\n    waiterObs = [];\n    waiters = {};\n    afters = [];\n    aftersIndex = 0;\n    afterTransaction = function(f) {\n      if (rootEvent) {\n        return afters.push(f);\n      } else {\n        return f();\n      }\n    };\n    whenDoneWith = function(obs, f) {\n      var obsWaiters;\n      if (rootEvent) {\n        obsWaiters = waiters[obs.id];\n        if (obsWaiters == null) {\n          obsWaiters = waiters[obs.id] = [f];\n          return waiterObs.push(obs);\n        } else {\n          return obsWaiters.push(f);\n        }\n      } else {\n        return f();\n      }\n    };\n    flush = function() {\n      while (waiterObs.length > 0) {\n        flushWaiters(0);\n      }\n      return void 0;\n    };\n    flushWaiters = function(index) {\n      var f, j, len1, obs, obsId, obsWaiters;\n      obs = waiterObs[index];\n      obsId = obs.id;\n      obsWaiters = waiters[obsId];\n      waiterObs.splice(index, 1);\n      delete waiters[obsId];\n      flushDepsOf(obs);\n      for (j = 0, len1 = obsWaiters.length; j < len1; j++) {\n        f = obsWaiters[j];\n        f();\n      }\n      return void 0;\n    };\n    flushDepsOf = function(obs) {\n      var dep, deps, index, j, len1;\n      deps = obs.internalDeps();\n      for (j = 0, len1 = deps.length; j < len1; j++) {\n        dep = deps[j];\n        flushDepsOf(dep);\n        if (waiters[dep.id]) {\n          index = _.indexOf(waiterObs, dep);\n          flushWaiters(index);\n        }\n      }\n      return void 0;\n    };\n    inTransaction = function(event, context, f, args) {\n      var after, result;\n      if (rootEvent) {\n        return f.apply(context, args);\n      } else {\n        rootEvent = event;\n        try {\n          result = f.apply(context, args);\n          flush();\n        } finally {\n          rootEvent = void 0;\n          while (aftersIndex < afters.length) {\n            after = afters[aftersIndex];\n            aftersIndex++;\n            after();\n          }\n          aftersIndex = 0;\n          afters = [];\n        }\n        return result;\n      }\n    };\n    currentEventId = function() {\n      if (rootEvent) {\n        return rootEvent.id;\n      } else {\n        return void 0;\n      }\n    };\n    wrappedSubscribe = function(obs, sink) {\n      var doUnsub, shouldUnsub, unsub, unsubd;\n      unsubd = false;\n      shouldUnsub = false;\n      doUnsub = function() {\n        return shouldUnsub = true;\n      };\n      unsub = function() {\n        unsubd = true;\n        return doUnsub();\n      };\n      doUnsub = obs.dispatcher.subscribe(function(event) {\n        return afterTransaction(function() {\n          var reply;\n          if (!unsubd) {\n            reply = sink(event);\n            if (reply === Bacon.noMore) {\n              return unsub();\n            }\n          }\n        });\n      });\n      if (shouldUnsub) {\n        doUnsub();\n      }\n      return unsub;\n    };\n    hasWaiters = function() {\n      return waiterObs.length > 0;\n    };\n    return {\n      whenDoneWith: whenDoneWith,\n      hasWaiters: hasWaiters,\n      inTransaction: inTransaction,\n      currentEventId: currentEventId,\n      wrappedSubscribe: wrappedSubscribe,\n      afterTransaction: afterTransaction\n    };\n  })();\n\n  Source = (function() {\n    function Source(obs1, sync, lazy1) {\n      this.obs = obs1;\n      this.sync = sync;\n      this.lazy = lazy1 != null ? lazy1 : false;\n      this.queue = [];\n    }\n\n    Source.prototype.subscribe = function(sink) {\n      return this.obs.dispatcher.subscribe(sink);\n    };\n\n    Source.prototype.toString = function() {\n      return this.obs.toString();\n    };\n\n    Source.prototype.markEnded = function() {\n      return this.ended = true;\n    };\n\n    Source.prototype.consume = function() {\n      if (this.lazy) {\n        return {\n          value: _.always(this.queue[0])\n        };\n      } else {\n        return this.queue[0];\n      }\n    };\n\n    Source.prototype.push = function(x) {\n      return this.queue = [x];\n    };\n\n    Source.prototype.mayHave = function() {\n      return true;\n    };\n\n    Source.prototype.hasAtLeast = function() {\n      return this.queue.length;\n    };\n\n    Source.prototype.flatten = true;\n\n    return Source;\n\n  })();\n\n  ConsumingSource = (function(superClass) {\n    extend(ConsumingSource, superClass);\n\n    function ConsumingSource() {\n      return ConsumingSource.__super__.constructor.apply(this, arguments);\n    }\n\n    ConsumingSource.prototype.consume = function() {\n      return this.queue.shift();\n    };\n\n    ConsumingSource.prototype.push = function(x) {\n      return this.queue.push(x);\n    };\n\n    ConsumingSource.prototype.mayHave = function(c) {\n      return !this.ended || this.queue.length >= c;\n    };\n\n    ConsumingSource.prototype.hasAtLeast = function(c) {\n      return this.queue.length >= c;\n    };\n\n    ConsumingSource.prototype.flatten = false;\n\n    return ConsumingSource;\n\n  })(Source);\n\n  BufferingSource = (function(superClass) {\n    extend(BufferingSource, superClass);\n\n    function BufferingSource(obs) {\n      BufferingSource.__super__.constructor.call(this, obs, true);\n    }\n\n    BufferingSource.prototype.consume = function() {\n      var values;\n      values = this.queue;\n      this.queue = [];\n      return {\n        value: function() {\n          return values;\n        }\n      };\n    };\n\n    BufferingSource.prototype.push = function(x) {\n      return this.queue.push(x.value());\n    };\n\n    BufferingSource.prototype.hasAtLeast = function() {\n      return true;\n    };\n\n    return BufferingSource;\n\n  })(Source);\n\n  Source.isTrigger = function(s) {\n    if (s instanceof Source) {\n      return s.sync;\n    } else {\n      return s instanceof EventStream;\n    }\n  };\n\n  Source.fromObservable = function(s) {\n    if (s instanceof Source) {\n      return s;\n    } else if (s instanceof Property) {\n      return new Source(s, false);\n    } else {\n      return new ConsumingSource(s, true);\n    }\n  };\n\n  Desc = (function() {\n    function Desc(context1, method1, args1) {\n      this.context = context1;\n      this.method = method1;\n      this.args = args1;\n    }\n\n    Desc.prototype.deps = function() {\n      return this.cached || (this.cached = findDeps([this.context].concat(this.args)));\n    };\n\n    Desc.prototype.toString = function() {\n      return _.toString(this.context) + \".\" + _.toString(this.method) + \"(\" + _.map(_.toString, this.args) + \")\";\n    };\n\n    return Desc;\n\n  })();\n\n  describe = function() {\n    var args, context, method;\n    context = arguments[0], method = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n    if ((context || method) instanceof Desc) {\n      return context || method;\n    } else {\n      return new Desc(context, method, args);\n    }\n  };\n\n  withDesc = function(desc, obs) {\n    obs.desc = desc;\n    return obs;\n  };\n\n  findDeps = function(x) {\n    if (isArray(x)) {\n      return _.flatMap(findDeps, x);\n    } else if (isObservable(x)) {\n      return [x];\n    } else if (x instanceof Source) {\n      return [x.obs];\n    } else {\n      return [];\n    }\n  };\n\n  Bacon.Desc = Desc;\n\n  Bacon.Desc.empty = new Bacon.Desc(\"\", \"\", []);\n\n  withMethodCallSupport = function(wrapped) {\n    return function() {\n      var args, context, f, methodName;\n      f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      if (typeof f === \"object\" && args.length) {\n        context = f;\n        methodName = args[0];\n        f = function() {\n          return context[methodName].apply(context, arguments);\n        };\n        args = args.slice(1);\n      }\n      return wrapped.apply(null, [f].concat(slice.call(args)));\n    };\n  };\n\n  makeFunctionArgs = function(args) {\n    args = Array.prototype.slice.call(args);\n    return makeFunction_.apply(null, args);\n  };\n\n  partiallyApplied = function(f, applied) {\n    return function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return f.apply(null, applied.concat(args));\n    };\n  };\n\n  toSimpleExtractor = function(args) {\n    return function(key) {\n      return function(value) {\n        var fieldValue;\n        if (value == null) {\n          return void 0;\n        } else {\n          fieldValue = value[key];\n          if (_.isFunction(fieldValue)) {\n            return fieldValue.apply(value, args);\n          } else {\n            return fieldValue;\n          }\n        }\n      };\n    };\n  };\n\n  toFieldExtractor = function(f, args) {\n    var partFuncs, parts;\n    parts = f.slice(1).split(\".\");\n    partFuncs = _.map(toSimpleExtractor(args), parts);\n    return function(value) {\n      var j, len1;\n      for (j = 0, len1 = partFuncs.length; j < len1; j++) {\n        f = partFuncs[j];\n        value = f(value);\n      }\n      return value;\n    };\n  };\n\n  isFieldKey = function(f) {\n    return (typeof f === \"string\") && f.length > 1 && f.charAt(0) === \".\";\n  };\n\n  makeFunction_ = withMethodCallSupport(function() {\n    var args, f;\n    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    if (_.isFunction(f)) {\n      if (args.length) {\n        return partiallyApplied(f, args);\n      } else {\n        return f;\n      }\n    } else if (isFieldKey(f)) {\n      return toFieldExtractor(f, args);\n    } else {\n      return _.always(f);\n    }\n  });\n\n  makeFunction = function(f, args) {\n    return makeFunction_.apply(null, [f].concat(slice.call(args)));\n  };\n\n  convertArgsToFunction = function(obs, f, args, method) {\n    var sampled;\n    if (f instanceof Property) {\n      sampled = f.sampledBy(obs, function(p, s) {\n        return [p, s];\n      });\n      return method.call(sampled, function(arg) {\n        var p, s;\n        p = arg[0], s = arg[1];\n        return p;\n      }).map(function(arg) {\n        var p, s;\n        p = arg[0], s = arg[1];\n        return s;\n      });\n    } else {\n      f = makeFunction(f, args);\n      return method.call(obs, f);\n    }\n  };\n\n  toCombinator = function(f) {\n    var key;\n    if (_.isFunction(f)) {\n      return f;\n    } else if (isFieldKey(f)) {\n      key = toFieldKey(f);\n      return function(left, right) {\n        return left[key](right);\n      };\n    } else {\n      throw new Exception(\"not a function or a field key: \" + f);\n    }\n  };\n\n  toFieldKey = function(f) {\n    return f.slice(1);\n  };\n\n  Some = (function() {\n    function Some(value1) {\n      this.value = value1;\n    }\n\n    Some.prototype.getOrElse = function() {\n      return this.value;\n    };\n\n    Some.prototype.get = function() {\n      return this.value;\n    };\n\n    Some.prototype.filter = function(f) {\n      if (f(this.value)) {\n        return new Some(this.value);\n      } else {\n        return None;\n      }\n    };\n\n    Some.prototype.map = function(f) {\n      return new Some(f(this.value));\n    };\n\n    Some.prototype.forEach = function(f) {\n      return f(this.value);\n    };\n\n    Some.prototype.isDefined = true;\n\n    Some.prototype.toArray = function() {\n      return [this.value];\n    };\n\n    Some.prototype.inspect = function() {\n      return \"Some(\" + this.value + \")\";\n    };\n\n    Some.prototype.toString = function() {\n      return this.inspect();\n    };\n\n    return Some;\n\n  })();\n\n  None = {\n    getOrElse: function(value) {\n      return value;\n    },\n    filter: function() {\n      return None;\n    },\n    map: function() {\n      return None;\n    },\n    forEach: function() {},\n    isDefined: false,\n    toArray: function() {\n      return [];\n    },\n    inspect: function() {\n      return \"None\";\n    },\n    toString: function() {\n      return this.inspect();\n    }\n  };\n\n  toOption = function(v) {\n    if (v instanceof Some || v === None) {\n      return v;\n    } else {\n      return new Some(v);\n    }\n  };\n\n  Bacon.noMore = [\"<no-more>\"];\n\n  Bacon.more = [\"<more>\"];\n\n  eventIdCounter = 0;\n\n  Event = (function() {\n    function Event() {\n      this.id = ++eventIdCounter;\n    }\n\n    Event.prototype.isEvent = function() {\n      return true;\n    };\n\n    Event.prototype.isEnd = function() {\n      return false;\n    };\n\n    Event.prototype.isInitial = function() {\n      return false;\n    };\n\n    Event.prototype.isNext = function() {\n      return false;\n    };\n\n    Event.prototype.isError = function() {\n      return false;\n    };\n\n    Event.prototype.hasValue = function() {\n      return false;\n    };\n\n    Event.prototype.filter = function() {\n      return true;\n    };\n\n    Event.prototype.inspect = function() {\n      return this.toString();\n    };\n\n    Event.prototype.log = function() {\n      return this.toString();\n    };\n\n    return Event;\n\n  })();\n\n  Next = (function(superClass) {\n    extend(Next, superClass);\n\n    function Next(valueF, eager) {\n      Next.__super__.constructor.call(this);\n      if (!eager && _.isFunction(valueF) || valueF instanceof Next) {\n        this.valueF = valueF;\n        this.valueInternal = void 0;\n      } else {\n        this.valueF = void 0;\n        this.valueInternal = valueF;\n      }\n    }\n\n    Next.prototype.isNext = function() {\n      return true;\n    };\n\n    Next.prototype.hasValue = function() {\n      return true;\n    };\n\n    Next.prototype.value = function() {\n      if (this.valueF instanceof Next) {\n        this.valueInternal = this.valueF.value();\n        this.valueF = void 0;\n      } else if (this.valueF) {\n        this.valueInternal = this.valueF();\n        this.valueF = void 0;\n      }\n      return this.valueInternal;\n    };\n\n    Next.prototype.fmap = function(f) {\n      var event, value;\n      if (this.valueInternal) {\n        value = this.valueInternal;\n        return this.apply(function() {\n          return f(value);\n        });\n      } else {\n        event = this;\n        return this.apply(function() {\n          return f(event.value());\n        });\n      }\n    };\n\n    Next.prototype.apply = function(value) {\n      return new Next(value);\n    };\n\n    Next.prototype.filter = function(f) {\n      return f(this.value());\n    };\n\n    Next.prototype.toString = function() {\n      return _.toString(this.value());\n    };\n\n    Next.prototype.log = function() {\n      return this.value();\n    };\n\n    return Next;\n\n  })(Event);\n\n  Initial = (function(superClass) {\n    extend(Initial, superClass);\n\n    function Initial() {\n      return Initial.__super__.constructor.apply(this, arguments);\n    }\n\n    Initial.prototype.isInitial = function() {\n      return true;\n    };\n\n    Initial.prototype.isNext = function() {\n      return false;\n    };\n\n    Initial.prototype.apply = function(value) {\n      return new Initial(value);\n    };\n\n    Initial.prototype.toNext = function() {\n      return new Next(this);\n    };\n\n    return Initial;\n\n  })(Next);\n\n  End = (function(superClass) {\n    extend(End, superClass);\n\n    function End() {\n      return End.__super__.constructor.apply(this, arguments);\n    }\n\n    End.prototype.isEnd = function() {\n      return true;\n    };\n\n    End.prototype.fmap = function() {\n      return this;\n    };\n\n    End.prototype.apply = function() {\n      return this;\n    };\n\n    End.prototype.toString = function() {\n      return \"<end>\";\n    };\n\n    return End;\n\n  })(Event);\n\n  Error = (function(superClass) {\n    extend(Error, superClass);\n\n    function Error(error1) {\n      this.error = error1;\n    }\n\n    Error.prototype.isError = function() {\n      return true;\n    };\n\n    Error.prototype.fmap = function() {\n      return this;\n    };\n\n    Error.prototype.apply = function() {\n      return this;\n    };\n\n    Error.prototype.toString = function() {\n      return \"<error> \" + _.toString(this.error);\n    };\n\n    return Error;\n\n  })(Event);\n\n  Bacon.Event = Event;\n\n  Bacon.Initial = Initial;\n\n  Bacon.Next = Next;\n\n  Bacon.End = End;\n\n  Bacon.Error = Error;\n\n  initialEvent = function(value) {\n    return new Initial(value, true);\n  };\n\n  nextEvent = function(value) {\n    return new Next(value, true);\n  };\n\n  endEvent = function() {\n    return new End();\n  };\n\n  toEvent = function(x) {\n    if (x instanceof Event) {\n      return x;\n    } else {\n      return nextEvent(x);\n    }\n  };\n\n  idCounter = 0;\n\n  registerObs = function() {};\n\n  Observable = (function() {\n    function Observable(desc1) {\n      this.desc = desc1;\n      this.id = ++idCounter;\n      this.initialDesc = this.desc;\n    }\n\n    Observable.prototype.subscribe = function(sink) {\n      return UpdateBarrier.wrappedSubscribe(this, sink);\n    };\n\n    Observable.prototype.subscribeInternal = function(sink) {\n      return this.dispatcher.subscribe(sink);\n    };\n\n    Observable.prototype.onValue = function() {\n      var f;\n      f = makeFunctionArgs(arguments);\n      return this.subscribe(function(event) {\n        if (event.hasValue()) {\n          return f(event.value());\n        }\n      });\n    };\n\n    Observable.prototype.onValues = function(f) {\n      return this.onValue(function(args) {\n        return f.apply(null, args);\n      });\n    };\n\n    Observable.prototype.onError = function() {\n      var f;\n      f = makeFunctionArgs(arguments);\n      return this.subscribe(function(event) {\n        if (event.isError()) {\n          return f(event.error);\n        }\n      });\n    };\n\n    Observable.prototype.onEnd = function() {\n      var f;\n      f = makeFunctionArgs(arguments);\n      return this.subscribe(function(event) {\n        if (event.isEnd()) {\n          return f();\n        }\n      });\n    };\n\n    Observable.prototype.name = function(name) {\n      this._name = name;\n      return this;\n    };\n\n    Observable.prototype.withDescription = function() {\n      this.desc = describe.apply(null, arguments);\n      return this;\n    };\n\n    Observable.prototype.toString = function() {\n      if (this._name) {\n        return this._name;\n      } else {\n        return this.desc.toString();\n      }\n    };\n\n    Observable.prototype.internalDeps = function() {\n      return this.initialDesc.deps();\n    };\n\n    return Observable;\n\n  })();\n\n  Observable.prototype.assign = Observable.prototype.onValue;\n\n  Observable.prototype.forEach = Observable.prototype.onValue;\n\n  Observable.prototype.inspect = Observable.prototype.toString;\n\n  Bacon.Observable = Observable;\n\n  CompositeUnsubscribe = (function() {\n    function CompositeUnsubscribe(ss) {\n      var j, len1, s;\n      if (ss == null) {\n        ss = [];\n      }\n      this.unsubscribe = bind(this.unsubscribe, this);\n      this.unsubscribed = false;\n      this.subscriptions = [];\n      this.starting = [];\n      for (j = 0, len1 = ss.length; j < len1; j++) {\n        s = ss[j];\n        this.add(s);\n      }\n    }\n\n    CompositeUnsubscribe.prototype.add = function(subscription) {\n      var ended, unsub, unsubMe;\n      if (this.unsubscribed) {\n        return;\n      }\n      ended = false;\n      unsub = nop;\n      this.starting.push(subscription);\n      unsubMe = (function(_this) {\n        return function() {\n          if (_this.unsubscribed) {\n            return;\n          }\n          ended = true;\n          _this.remove(unsub);\n          return _.remove(subscription, _this.starting);\n        };\n      })(this);\n      unsub = subscription(this.unsubscribe, unsubMe);\n      if (!(this.unsubscribed || ended)) {\n        this.subscriptions.push(unsub);\n      } else {\n        unsub();\n      }\n      _.remove(subscription, this.starting);\n      return unsub;\n    };\n\n    CompositeUnsubscribe.prototype.remove = function(unsub) {\n      if (this.unsubscribed) {\n        return;\n      }\n      if ((_.remove(unsub, this.subscriptions)) !== void 0) {\n        return unsub();\n      }\n    };\n\n    CompositeUnsubscribe.prototype.unsubscribe = function() {\n      var j, len1, ref, s;\n      if (this.unsubscribed) {\n        return;\n      }\n      this.unsubscribed = true;\n      ref = this.subscriptions;\n      for (j = 0, len1 = ref.length; j < len1; j++) {\n        s = ref[j];\n        s();\n      }\n      this.subscriptions = [];\n      return this.starting = [];\n    };\n\n    CompositeUnsubscribe.prototype.count = function() {\n      if (this.unsubscribed) {\n        return 0;\n      }\n      return this.subscriptions.length + this.starting.length;\n    };\n\n    CompositeUnsubscribe.prototype.empty = function() {\n      return this.count() === 0;\n    };\n\n    return CompositeUnsubscribe;\n\n  })();\n\n  Bacon.CompositeUnsubscribe = CompositeUnsubscribe;\n\n  Dispatcher = (function() {\n    Dispatcher.prototype.pushing = false;\n\n    Dispatcher.prototype.ended = false;\n\n    Dispatcher.prototype.prevError = void 0;\n\n    Dispatcher.prototype.unsubSrc = void 0;\n\n    function Dispatcher(_subscribe, _handleEvent) {\n      this._subscribe = _subscribe;\n      this._handleEvent = _handleEvent;\n      this.subscribe = bind(this.subscribe, this);\n      this.handleEvent = bind(this.handleEvent, this);\n      this.subscriptions = [];\n      this.queue = [];\n    }\n\n    Dispatcher.prototype.hasSubscribers = function() {\n      return this.subscriptions.length > 0;\n    };\n\n    Dispatcher.prototype.removeSub = function(subscription) {\n      return this.subscriptions = _.without(subscription, this.subscriptions);\n    };\n\n    Dispatcher.prototype.push = function(event) {\n      if (event.isEnd()) {\n        this.ended = true;\n      }\n      return UpdateBarrier.inTransaction(event, this, this.pushIt, [event]);\n    };\n\n    Dispatcher.prototype.pushToSubscriptions = function(event) {\n      var e, j, len1, reply, sub, tmp;\n      try {\n        tmp = this.subscriptions;\n        for (j = 0, len1 = tmp.length; j < len1; j++) {\n          sub = tmp[j];\n          reply = sub.sink(event);\n          if (reply === Bacon.noMore || event.isEnd()) {\n            this.removeSub(sub);\n          }\n        }\n        return true;\n      } catch (_error) {\n        e = _error;\n        this.pushing = false;\n        this.queue = [];\n        throw e;\n      }\n    };\n\n    Dispatcher.prototype.pushIt = function(event) {\n      if (!this.pushing) {\n        if (event === this.prevError) {\n          return;\n        }\n        if (event.isError()) {\n          this.prevError = event;\n        }\n        this.pushing = true;\n        this.pushToSubscriptions(event);\n        this.pushing = false;\n        while (this.queue.length) {\n          event = this.queue.shift();\n          this.push(event);\n        }\n        if (this.hasSubscribers()) {\n          return Bacon.more;\n        } else {\n          this.unsubscribeFromSource();\n          return Bacon.noMore;\n        }\n      } else {\n        this.queue.push(event);\n        return Bacon.more;\n      }\n    };\n\n    Dispatcher.prototype.handleEvent = function(event) {\n      if (this._handleEvent) {\n        return this._handleEvent(event);\n      } else {\n        return this.push(event);\n      }\n    };\n\n    Dispatcher.prototype.unsubscribeFromSource = function() {\n      if (this.unsubSrc) {\n        this.unsubSrc();\n      }\n      return this.unsubSrc = void 0;\n    };\n\n    Dispatcher.prototype.subscribe = function(sink) {\n      var subscription;\n      if (this.ended) {\n        sink(endEvent());\n        return nop;\n      } else {\n        assertFunction(sink);\n        subscription = {\n          sink: sink\n        };\n        this.subscriptions.push(subscription);\n        if (this.subscriptions.length === 1) {\n          this.unsubSrc = this._subscribe(this.handleEvent);\n          assertFunction(this.unsubSrc);\n        }\n        return (function(_this) {\n          return function() {\n            _this.removeSub(subscription);\n            if (!_this.hasSubscribers()) {\n              return _this.unsubscribeFromSource();\n            }\n          };\n        })(this);\n      }\n    };\n\n    return Dispatcher;\n\n  })();\n\n  Bacon.Dispatcher = Dispatcher;\n\n  EventStream = (function(superClass) {\n    extend(EventStream, superClass);\n\n    function EventStream(desc, subscribe, handler) {\n      if (_.isFunction(desc)) {\n        handler = subscribe;\n        subscribe = desc;\n        desc = Desc.empty;\n      }\n      EventStream.__super__.constructor.call(this, desc);\n      assertFunction(subscribe);\n      this.dispatcher = new Dispatcher(subscribe, handler);\n      registerObs(this);\n    }\n\n    EventStream.prototype.toProperty = function(initValue_) {\n      var disp, initValue;\n      initValue = arguments.length === 0 ? None : toOption(function() {\n        return initValue_;\n      });\n      disp = this.dispatcher;\n      return new Property(new Bacon.Desc(this, \"toProperty\", [initValue_]), function(sink) {\n        var initSent, reply, sendInit, unsub;\n        initSent = false;\n        unsub = nop;\n        reply = Bacon.more;\n        sendInit = function() {\n          if (!initSent) {\n            return initValue.forEach(function(value) {\n              initSent = true;\n              reply = sink(new Initial(value));\n              if (reply === Bacon.noMore) {\n                unsub();\n                return unsub = nop;\n              }\n            });\n          }\n        };\n        unsub = disp.subscribe(function(event) {\n          if (event.hasValue()) {\n            if (initSent && event.isInitial()) {\n              return Bacon.more;\n            } else {\n              if (!event.isInitial()) {\n                sendInit();\n              }\n              initSent = true;\n              initValue = new Some(event);\n              return sink(event);\n            }\n          } else {\n            if (event.isEnd()) {\n              reply = sendInit();\n            }\n            if (reply !== Bacon.noMore) {\n              return sink(event);\n            }\n          }\n        });\n        sendInit();\n        return unsub;\n      });\n    };\n\n    EventStream.prototype.toEventStream = function() {\n      return this;\n    };\n\n    EventStream.prototype.withHandler = function(handler) {\n      return new EventStream(new Bacon.Desc(this, \"withHandler\", [handler]), this.dispatcher.subscribe, handler);\n    };\n\n    return EventStream;\n\n  })(Observable);\n\n  Bacon.EventStream = EventStream;\n\n  Bacon.never = function() {\n    return new EventStream(describe(Bacon, \"never\"), function(sink) {\n      sink(endEvent());\n      return nop;\n    });\n  };\n\n  Bacon.when = function() {\n    var f, i, index, ix, j, k, len, len1, len2, needsBarrier, pat, patSources, pats, patterns, ref, resultStream, s, sources, triggerFound, usage;\n    if (arguments.length === 0) {\n      return Bacon.never();\n    }\n    len = arguments.length;\n    usage = \"when: expecting arguments in the form (Observable+,function)+\";\n    assert(usage, len % 2 === 0);\n    sources = [];\n    pats = [];\n    i = 0;\n    patterns = [];\n    while (i < len) {\n      patterns[i] = arguments[i];\n      patterns[i + 1] = arguments[i + 1];\n      patSources = _.toArray(arguments[i]);\n      f = constantToFunction(arguments[i + 1]);\n      pat = {\n        f: f,\n        ixs: []\n      };\n      triggerFound = false;\n      for (j = 0, len1 = patSources.length; j < len1; j++) {\n        s = patSources[j];\n        index = _.indexOf(sources, s);\n        if (!triggerFound) {\n          triggerFound = Source.isTrigger(s);\n        }\n        if (index < 0) {\n          sources.push(s);\n          index = sources.length - 1;\n        }\n        ref = pat.ixs;\n        for (k = 0, len2 = ref.length; k < len2; k++) {\n          ix = ref[k];\n          if (ix.index === index) {\n            ix.count++;\n          }\n        }\n        pat.ixs.push({\n          index: index,\n          count: 1\n        });\n      }\n      assert(\"At least one EventStream required\", triggerFound || (!patSources.length));\n      if (patSources.length > 0) {\n        pats.push(pat);\n      }\n      i = i + 2;\n    }\n    if (!sources.length) {\n      return Bacon.never();\n    }\n    sources = _.map(Source.fromObservable, sources);\n    needsBarrier = (_.any(sources, function(s) {\n      return s.flatten;\n    })) && (containsDuplicateDeps(_.map((function(s) {\n      return s.obs;\n    }), sources)));\n    return resultStream = new EventStream(new Bacon.Desc(Bacon, \"when\", patterns), function(sink) {\n      var cannotMatch, cannotSync, ends, match, nonFlattened, part, triggers;\n      triggers = [];\n      ends = false;\n      match = function(p) {\n        var l, len3, ref1;\n        ref1 = p.ixs;\n        for (l = 0, len3 = ref1.length; l < len3; l++) {\n          i = ref1[l];\n          if (!sources[i.index].hasAtLeast(i.count)) {\n            return false;\n          }\n        }\n        return true;\n      };\n      cannotSync = function(source) {\n        return !source.sync || source.ended;\n      };\n      cannotMatch = function(p) {\n        var l, len3, ref1;\n        ref1 = p.ixs;\n        for (l = 0, len3 = ref1.length; l < len3; l++) {\n          i = ref1[l];\n          if (!sources[i.index].mayHave(i.count)) {\n            return true;\n          }\n        }\n      };\n      nonFlattened = function(trigger) {\n        return !trigger.source.flatten;\n      };\n      part = function(source) {\n        return function(unsubAll) {\n          var flush, flushLater, flushWhileTriggers;\n          flushLater = function() {\n            return UpdateBarrier.whenDoneWith(resultStream, flush);\n          };\n          flushWhileTriggers = function() {\n            var events, l, len3, p, reply, trigger;\n            if (triggers.length > 0) {\n              reply = Bacon.more;\n              trigger = triggers.pop();\n              for (l = 0, len3 = pats.length; l < len3; l++) {\n                p = pats[l];\n                if (match(p)) {\n                  events = (function() {\n                    var len4, m, ref1, results;\n                    ref1 = p.ixs;\n                    results = [];\n                    for (m = 0, len4 = ref1.length; m < len4; m++) {\n                      i = ref1[m];\n                      results.push(sources[i.index].consume());\n                    }\n                    return results;\n                  })();\n                  reply = sink(trigger.e.apply(function() {\n                    var event, values;\n                    values = (function() {\n                      var len4, m, results;\n                      results = [];\n                      for (m = 0, len4 = events.length; m < len4; m++) {\n                        event = events[m];\n                        results.push(event.value());\n                      }\n                      return results;\n                    })();\n                    return p.f.apply(p, values);\n                  }));\n                  if (triggers.length) {\n                    triggers = _.filter(nonFlattened, triggers);\n                  }\n                  if (reply === Bacon.noMore) {\n                    return reply;\n                  } else {\n                    return flushWhileTriggers();\n                  }\n                }\n              }\n            } else {\n              return Bacon.more;\n            }\n          };\n          flush = function() {\n            var reply;\n            reply = flushWhileTriggers();\n            if (ends) {\n              if (_.all(sources, cannotSync) || _.all(pats, cannotMatch)) {\n                reply = Bacon.noMore;\n                sink(endEvent());\n              }\n            }\n            if (reply === Bacon.noMore) {\n              unsubAll();\n            }\n            return reply;\n          };\n          return source.subscribe(function(e) {\n            var reply;\n            if (e.isEnd()) {\n              ends = true;\n              source.markEnded();\n              flushLater();\n            } else if (e.isError()) {\n              reply = sink(e);\n            } else {\n              source.push(e);\n              if (source.sync) {\n                triggers.push({\n                  source: source,\n                  e: e\n                });\n                if (needsBarrier || UpdateBarrier.hasWaiters()) {\n                  flushLater();\n                } else {\n                  flush();\n                }\n              }\n            }\n            if (reply === Bacon.noMore) {\n              unsubAll();\n            }\n            return reply || Bacon.more;\n          });\n        };\n      };\n      return new Bacon.CompositeUnsubscribe((function() {\n        var l, len3, results;\n        results = [];\n        for (l = 0, len3 = sources.length; l < len3; l++) {\n          s = sources[l];\n          results.push(part(s));\n        }\n        return results;\n      })()).unsubscribe;\n    });\n  };\n\n  containsDuplicateDeps = function(observables, state) {\n    var checkObservable;\n    if (state == null) {\n      state = [];\n    }\n    checkObservable = function(obs) {\n      var deps;\n      if (_.contains(state, obs)) {\n        return true;\n      } else {\n        deps = obs.internalDeps();\n        if (deps.length) {\n          state.push(obs);\n          return _.any(deps, checkObservable);\n        } else {\n          state.push(obs);\n          return false;\n        }\n      }\n    };\n    return _.any(observables, checkObservable);\n  };\n\n  constantToFunction = function(f) {\n    if (_.isFunction(f)) {\n      return f;\n    } else {\n      return _.always(f);\n    }\n  };\n\n  Bacon.groupSimultaneous = function() {\n    var s, sources, streams;\n    streams = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    if (streams.length === 1 && isArray(streams[0])) {\n      streams = streams[0];\n    }\n    sources = (function() {\n      var j, len1, results;\n      results = [];\n      for (j = 0, len1 = streams.length; j < len1; j++) {\n        s = streams[j];\n        results.push(new BufferingSource(s));\n      }\n      return results;\n    })();\n    return withDesc(new Bacon.Desc(Bacon, \"groupSimultaneous\", streams), Bacon.when(sources, (function() {\n      var xs;\n      xs = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return xs;\n    })));\n  };\n\n  PropertyDispatcher = (function(superClass) {\n    extend(PropertyDispatcher, superClass);\n\n    function PropertyDispatcher(property1, subscribe, handleEvent) {\n      this.property = property1;\n      this.subscribe = bind(this.subscribe, this);\n      PropertyDispatcher.__super__.constructor.call(this, subscribe, handleEvent);\n      this.current = None;\n      this.currentValueRootId = void 0;\n      this.propertyEnded = false;\n    }\n\n    PropertyDispatcher.prototype.push = function(event) {\n      if (event.isEnd()) {\n        this.propertyEnded = true;\n      }\n      if (event.hasValue()) {\n        this.current = new Some(event);\n        this.currentValueRootId = UpdateBarrier.currentEventId();\n      }\n      return PropertyDispatcher.__super__.push.call(this, event);\n    };\n\n    PropertyDispatcher.prototype.maybeSubSource = function(sink, reply) {\n      if (reply === Bacon.noMore) {\n        return nop;\n      } else if (this.propertyEnded) {\n        sink(endEvent());\n        return nop;\n      } else {\n        return Dispatcher.prototype.subscribe.call(this, sink);\n      }\n    };\n\n    PropertyDispatcher.prototype.subscribe = function(sink) {\n      var dispatchingId, initSent, reply, valId;\n      initSent = false;\n      reply = Bacon.more;\n      if (this.current.isDefined && (this.hasSubscribers() || this.propertyEnded)) {\n        dispatchingId = UpdateBarrier.currentEventId();\n        valId = this.currentValueRootId;\n        if (!this.propertyEnded && valId && dispatchingId && dispatchingId !== valId) {\n          UpdateBarrier.whenDoneWith(this.property, (function(_this) {\n            return function() {\n              if (_this.currentValueRootId === valId) {\n                return sink(initialEvent(_this.current.get().value()));\n              }\n            };\n          })(this));\n          return this.maybeSubSource(sink, reply);\n        } else {\n          UpdateBarrier.inTransaction(void 0, this, (function() {\n            return reply = sink(initialEvent(this.current.get().value()));\n          }), []);\n          return this.maybeSubSource(sink, reply);\n        }\n      } else {\n        return this.maybeSubSource(sink, reply);\n      }\n    };\n\n    return PropertyDispatcher;\n\n  })(Dispatcher);\n\n  Property = (function(superClass) {\n    extend(Property, superClass);\n\n    function Property(desc, subscribe, handler) {\n      Property.__super__.constructor.call(this, desc);\n      assertFunction(subscribe);\n      this.dispatcher = new PropertyDispatcher(this, subscribe, handler);\n      registerObs(this);\n    }\n\n    Property.prototype.changes = function() {\n      return new EventStream(new Bacon.Desc(this, \"changes\", []), (function(_this) {\n        return function(sink) {\n          return _this.dispatcher.subscribe(function(event) {\n            if (!event.isInitial()) {\n              return sink(event);\n            }\n          });\n        };\n      })(this));\n    };\n\n    Property.prototype.withHandler = function(handler) {\n      return new Property(new Bacon.Desc(this, \"withHandler\", [handler]), this.dispatcher.subscribe, handler);\n    };\n\n    Property.prototype.toProperty = function() {\n      assertNoArguments(arguments);\n      return this;\n    };\n\n    Property.prototype.toEventStream = function() {\n      return new EventStream(new Bacon.Desc(this, \"toEventStream\", []), (function(_this) {\n        return function(sink) {\n          return _this.dispatcher.subscribe(function(event) {\n            if (event.isInitial()) {\n              event = event.toNext();\n            }\n            return sink(event);\n          });\n        };\n      })(this));\n    };\n\n    return Property;\n\n  })(Observable);\n\n  Bacon.Property = Property;\n\n  Bacon.constant = function(value) {\n    return new Property(new Bacon.Desc(Bacon, \"constant\", [value]), function(sink) {\n      sink(initialEvent(value));\n      sink(endEvent());\n      return nop;\n    });\n  };\n\n  Bacon.fromBinder = function(binder, eventTransformer) {\n    if (eventTransformer == null) {\n      eventTransformer = _.id;\n    }\n    return new EventStream(new Bacon.Desc(Bacon, \"fromBinder\", [binder, eventTransformer]), function(sink) {\n      var shouldUnbind, unbind, unbinder, unbound;\n      unbound = false;\n      shouldUnbind = false;\n      unbind = function() {\n        if (!unbound) {\n          if (typeof unbinder !== \"undefined\" && unbinder !== null) {\n            unbinder();\n            return unbound = true;\n          } else {\n            return shouldUnbind = true;\n          }\n        }\n      };\n      unbinder = binder(function() {\n        var args, event, j, len1, reply, value;\n        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        value = eventTransformer.apply(this, args);\n        if (!(isArray(value) && _.last(value) instanceof Event)) {\n          value = [value];\n        }\n        reply = Bacon.more;\n        for (j = 0, len1 = value.length; j < len1; j++) {\n          event = value[j];\n          reply = sink(event = toEvent(event));\n          if (reply === Bacon.noMore || event.isEnd()) {\n            unbind();\n            return reply;\n          }\n        }\n        return reply;\n      });\n      if (shouldUnbind) {\n        unbind();\n      }\n      return unbind;\n    });\n  };\n\n  eventMethods = [[\"addEventListener\", \"removeEventListener\"], [\"addListener\", \"removeListener\"], [\"on\", \"off\"], [\"bind\", \"unbind\"]];\n\n  findHandlerMethods = function(target) {\n    var j, len1, methodPair, pair;\n    for (j = 0, len1 = eventMethods.length; j < len1; j++) {\n      pair = eventMethods[j];\n      methodPair = [target[pair[0]], target[pair[1]]];\n      if (methodPair[0] && methodPair[1]) {\n        return methodPair;\n      }\n    }\n    throw new Error(\"No suitable event methods in \" + target);\n  };\n\n  Bacon.fromEventTarget = function(target, eventName, eventTransformer) {\n    var ref, sub, unsub;\n    ref = findHandlerMethods(target), sub = ref[0], unsub = ref[1];\n    return withDesc(new Bacon.Desc(Bacon, \"fromEvent\", [target, eventName]), Bacon.fromBinder(function(handler) {\n      sub.call(target, eventName, handler);\n      return function() {\n        return unsub.call(target, eventName, handler);\n      };\n    }, eventTransformer));\n  };\n\n  Bacon.fromEvent = Bacon.fromEventTarget;\n\n  Bacon.Observable.prototype.map = function() {\n    var args, p;\n    p = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return convertArgsToFunction(this, p, args, function(f) {\n      return withDesc(new Bacon.Desc(this, \"map\", [f]), this.withHandler(function(event) {\n        return this.push(event.fmap(f));\n      }));\n    });\n  };\n\n  argumentsToObservables = function(args) {\n    if (isArray(args[0])) {\n      return args[0];\n    } else {\n      return Array.prototype.slice.call(args);\n    }\n  };\n\n  argumentsToObservablesAndFunction = function(args) {\n    if (_.isFunction(args[0])) {\n      return [argumentsToObservables(Array.prototype.slice.call(args, 1)), args[0]];\n    } else {\n      return [argumentsToObservables(Array.prototype.slice.call(args, 0, args.length - 1)), _.last(args)];\n    }\n  };\n\n  Bacon.combineAsArray = function() {\n    var index, j, len1, s, sources, stream, streams;\n    streams = argumentsToObservables(arguments);\n    for (index = j = 0, len1 = streams.length; j < len1; index = ++j) {\n      stream = streams[index];\n      if (!(isObservable(stream))) {\n        streams[index] = Bacon.constant(stream);\n      }\n    }\n    if (streams.length) {\n      sources = (function() {\n        var k, len2, results;\n        results = [];\n        for (k = 0, len2 = streams.length; k < len2; k++) {\n          s = streams[k];\n          results.push(new Source(s, true));\n        }\n        return results;\n      })();\n      return withDesc(new Bacon.Desc(Bacon, \"combineAsArray\", streams), Bacon.when(sources, (function() {\n        var xs;\n        xs = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        return xs;\n      })).toProperty());\n    } else {\n      return Bacon.constant([]);\n    }\n  };\n\n  Bacon.onValues = function() {\n    var f, j, streams;\n    streams = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), f = arguments[j++];\n    return Bacon.combineAsArray(streams).onValues(f);\n  };\n\n  Bacon.combineWith = function() {\n    var f, ref, streams;\n    ref = argumentsToObservablesAndFunction(arguments), streams = ref[0], f = ref[1];\n    return withDesc(new Bacon.Desc(Bacon, \"combineWith\", [f].concat(slice.call(streams))), Bacon.combineAsArray(streams).map(function(values) {\n      return f.apply(null, values);\n    }));\n  };\n\n  Bacon.Observable.prototype.combine = function(other, f) {\n    var combinator;\n    combinator = toCombinator(f);\n    return withDesc(new Bacon.Desc(this, \"combine\", [other, f]), Bacon.combineAsArray(this, other).map(function(values) {\n      return combinator(values[0], values[1]);\n    }));\n  };\n\n  Bacon.Observable.prototype.withStateMachine = function(initState, f) {\n    var state;\n    state = initState;\n    return withDesc(new Bacon.Desc(this, \"withStateMachine\", [initState, f]), this.withHandler(function(event) {\n      var fromF, j, len1, newState, output, outputs, reply;\n      fromF = f(state, event);\n      newState = fromF[0], outputs = fromF[1];\n      state = newState;\n      reply = Bacon.more;\n      for (j = 0, len1 = outputs.length; j < len1; j++) {\n        output = outputs[j];\n        reply = this.push(output);\n        if (reply === Bacon.noMore) {\n          return reply;\n        }\n      }\n      return reply;\n    }));\n  };\n\n  Bacon.Observable.prototype.skipDuplicates = function(isEqual) {\n    if (isEqual == null) {\n      isEqual = function(a, b) {\n        return a === b;\n      };\n    }\n    return withDesc(new Bacon.Desc(this, \"skipDuplicates\", []), this.withStateMachine(None, function(prev, event) {\n      if (!event.hasValue()) {\n        return [prev, [event]];\n      } else if (event.isInitial() || prev === None || !isEqual(prev.get(), event.value())) {\n        return [new Some(event.value()), [event]];\n      } else {\n        return [prev, []];\n      }\n    }));\n  };\n\n  Bacon.Observable.prototype.awaiting = function(other) {\n    return withDesc(new Bacon.Desc(this, \"awaiting\", [other]), Bacon.groupSimultaneous(this, other).map(function(arg) {\n      var myValues, otherValues;\n      myValues = arg[0], otherValues = arg[1];\n      return otherValues.length === 0;\n    }).toProperty(false).skipDuplicates());\n  };\n\n  Bacon.Observable.prototype.not = function() {\n    return withDesc(new Bacon.Desc(this, \"not\", []), this.map(function(x) {\n      return !x;\n    }));\n  };\n\n  Bacon.Property.prototype.and = function(other) {\n    return withDesc(new Bacon.Desc(this, \"and\", [other]), this.combine(other, function(x, y) {\n      return x && y;\n    }));\n  };\n\n  Bacon.Property.prototype.or = function(other) {\n    return withDesc(new Bacon.Desc(this, \"or\", [other]), this.combine(other, function(x, y) {\n      return x || y;\n    }));\n  };\n\n  Bacon.scheduler = {\n    setTimeout: function(f, d) {\n      return setTimeout(f, d);\n    },\n    setInterval: function(f, i) {\n      return setInterval(f, i);\n    },\n    clearInterval: function(id) {\n      return clearInterval(id);\n    },\n    clearTimeout: function(id) {\n      return clearTimeout(id);\n    },\n    now: function() {\n      return new Date().getTime();\n    }\n  };\n\n  Bacon.EventStream.prototype.bufferWithTime = function(delay) {\n    return withDesc(new Bacon.Desc(this, \"bufferWithTime\", [delay]), this.bufferWithTimeOrCount(delay, Number.MAX_VALUE));\n  };\n\n  Bacon.EventStream.prototype.bufferWithCount = function(count) {\n    return withDesc(new Bacon.Desc(this, \"bufferWithCount\", [count]), this.bufferWithTimeOrCount(void 0, count));\n  };\n\n  Bacon.EventStream.prototype.bufferWithTimeOrCount = function(delay, count) {\n    var flushOrSchedule;\n    flushOrSchedule = function(buffer) {\n      if (buffer.values.length === count) {\n        return buffer.flush();\n      } else if (delay !== void 0) {\n        return buffer.schedule();\n      }\n    };\n    return withDesc(new Bacon.Desc(this, \"bufferWithTimeOrCount\", [delay, count]), this.buffer(delay, flushOrSchedule, flushOrSchedule));\n  };\n\n  Bacon.EventStream.prototype.buffer = function(delay, onInput, onFlush) {\n    var buffer, delayMs, reply;\n    if (onInput == null) {\n      onInput = nop;\n    }\n    if (onFlush == null) {\n      onFlush = nop;\n    }\n    buffer = {\n      scheduled: null,\n      end: void 0,\n      values: [],\n      flush: function() {\n        var reply, valuesToPush;\n        if (this.scheduled) {\n          Bacon.scheduler.clearTimeout(this.scheduled);\n          this.scheduled = null;\n        }\n        if (this.values.length > 0) {\n          valuesToPush = this.values;\n          this.values = [];\n          reply = this.push(nextEvent(valuesToPush));\n          if (this.end != null) {\n            return this.push(this.end);\n          } else if (reply !== Bacon.noMore) {\n            return onFlush(this);\n          }\n        } else {\n          if (this.end != null) {\n            return this.push(this.end);\n          }\n        }\n      },\n      schedule: function() {\n        if (!this.scheduled) {\n          return this.scheduled = delay((function(_this) {\n            return function() {\n              return _this.flush();\n            };\n          })(this));\n        }\n      }\n    };\n    reply = Bacon.more;\n    if (!_.isFunction(delay)) {\n      delayMs = delay;\n      delay = function(f) {\n        return Bacon.scheduler.setTimeout(f, delayMs);\n      };\n    }\n    return withDesc(new Bacon.Desc(this, \"buffer\", []), this.withHandler(function(event) {\n      buffer.push = (function(_this) {\n        return function(event) {\n          return _this.push(event);\n        };\n      })(this);\n      if (event.isError()) {\n        reply = this.push(event);\n      } else if (event.isEnd()) {\n        buffer.end = event;\n        if (!buffer.scheduled) {\n          buffer.flush();\n        }\n      } else {\n        buffer.values.push(event.value());\n        onInput(buffer);\n      }\n      return reply;\n    }));\n  };\n\n  Bacon.Observable.prototype.filter = function() {\n    var args, f;\n    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    assertObservableIsProperty(f);\n    return convertArgsToFunction(this, f, args, function(f) {\n      return withDesc(new Bacon.Desc(this, \"filter\", [f]), this.withHandler(function(event) {\n        if (event.filter(f)) {\n          return this.push(event);\n        } else {\n          return Bacon.more;\n        }\n      }));\n    });\n  };\n\n  Bacon.once = function(value) {\n    return new EventStream(new Desc(Bacon, \"once\", [value]), function(sink) {\n      sink(toEvent(value));\n      sink(endEvent());\n      return nop;\n    });\n  };\n\n  Bacon.EventStream.prototype.concat = function(right) {\n    var left;\n    left = this;\n    return new EventStream(new Bacon.Desc(left, \"concat\", [right]), function(sink) {\n      var unsubLeft, unsubRight;\n      unsubRight = nop;\n      unsubLeft = left.dispatcher.subscribe(function(e) {\n        if (e.isEnd()) {\n          return unsubRight = right.dispatcher.subscribe(sink);\n        } else {\n          return sink(e);\n        }\n      });\n      return function() {\n        unsubLeft();\n        return unsubRight();\n      };\n    });\n  };\n\n  Bacon.Observable.prototype.flatMap = function() {\n    return flatMap_(this, makeSpawner(arguments));\n  };\n\n  Bacon.Observable.prototype.flatMapFirst = function() {\n    return flatMap_(this, makeSpawner(arguments), true);\n  };\n\n  flatMap_ = function(root, f, firstOnly, limit) {\n    var childDeps, result, rootDep;\n    rootDep = [root];\n    childDeps = [];\n    result = new EventStream(new Bacon.Desc(root, \"flatMap\" + (firstOnly ? \"First\" : \"\"), [f]), function(sink) {\n      var checkEnd, checkQueue, composite, queue, spawn;\n      composite = new CompositeUnsubscribe();\n      queue = [];\n      spawn = function(event) {\n        var child;\n        child = makeObservable(f(event.value()));\n        childDeps.push(child);\n        return composite.add(function(unsubAll, unsubMe) {\n          return child.dispatcher.subscribe(function(event) {\n            var reply;\n            if (event.isEnd()) {\n              _.remove(child, childDeps);\n              checkQueue();\n              checkEnd(unsubMe);\n              return Bacon.noMore;\n            } else {\n              if (event instanceof Initial) {\n                event = event.toNext();\n              }\n              reply = sink(event);\n              if (reply === Bacon.noMore) {\n                unsubAll();\n              }\n              return reply;\n            }\n          });\n        });\n      };\n      checkQueue = function() {\n        var event;\n        event = queue.shift();\n        if (event) {\n          return spawn(event);\n        }\n      };\n      checkEnd = function(unsub) {\n        unsub();\n        if (composite.empty()) {\n          return sink(endEvent());\n        }\n      };\n      composite.add(function(__, unsubRoot) {\n        return root.dispatcher.subscribe(function(event) {\n          if (event.isEnd()) {\n            return checkEnd(unsubRoot);\n          } else if (event.isError()) {\n            return sink(event);\n          } else if (firstOnly && composite.count() > 1) {\n            return Bacon.more;\n          } else {\n            if (composite.unsubscribed) {\n              return Bacon.noMore;\n            }\n            if (limit && composite.count() > limit) {\n              return queue.push(event);\n            } else {\n              return spawn(event);\n            }\n          }\n        });\n      });\n      return composite.unsubscribe;\n    });\n    result.internalDeps = function() {\n      if (childDeps.length) {\n        return rootDep.concat(childDeps);\n      } else {\n        return rootDep;\n      }\n    };\n    return result;\n  };\n\n  makeSpawner = function(args) {\n    if (args.length === 1 && isObservable(args[0])) {\n      return _.always(args[0]);\n    } else {\n      return makeFunctionArgs(args);\n    }\n  };\n\n  makeObservable = function(x) {\n    if (isObservable(x)) {\n      return x;\n    } else {\n      return Bacon.once(x);\n    }\n  };\n\n  Bacon.Observable.prototype.flatMapWithConcurrencyLimit = function() {\n    var args, limit;\n    limit = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return withDesc(new Bacon.Desc(this, \"flatMapWithConcurrencyLimit\", [limit].concat(slice.call(args))), flatMap_(this, makeSpawner(args), false, limit));\n  };\n\n  Bacon.Observable.prototype.flatMapConcat = function() {\n    return withDesc(new Bacon.Desc(this, \"flatMapConcat\", Array.prototype.slice.call(arguments, 0)), this.flatMapWithConcurrencyLimit.apply(this, [1].concat(slice.call(arguments))));\n  };\n\n  Bacon.later = function(delay, value) {\n    return withDesc(new Bacon.Desc(Bacon, \"later\", [delay, value]), Bacon.fromBinder(function(sink) {\n      var id, sender;\n      sender = function() {\n        return sink([value, endEvent()]);\n      };\n      id = Bacon.scheduler.setTimeout(sender, delay);\n      return function() {\n        return Bacon.scheduler.clearTimeout(id);\n      };\n    }));\n  };\n\n  Bacon.Observable.prototype.bufferingThrottle = function(minimumInterval) {\n    return withDesc(new Bacon.Desc(this, \"bufferingThrottle\", [minimumInterval]), this.flatMapConcat(function(x) {\n      return Bacon.once(x).concat(Bacon.later(minimumInterval).filter(false));\n    }));\n  };\n\n  Bacon.Property.prototype.bufferingThrottle = function() {\n    return Bacon.Observable.prototype.bufferingThrottle.apply(this, arguments).toProperty();\n  };\n\n  Bus = (function(superClass) {\n    extend(Bus, superClass);\n\n    function Bus() {\n      this.guardedSink = bind(this.guardedSink, this);\n      this.subscribeAll = bind(this.subscribeAll, this);\n      this.unsubAll = bind(this.unsubAll, this);\n      this.sink = void 0;\n      this.subscriptions = [];\n      this.ended = false;\n      Bus.__super__.constructor.call(this, new Bacon.Desc(Bacon, \"Bus\", []), this.subscribeAll);\n    }\n\n    Bus.prototype.unsubAll = function() {\n      var j, len1, ref, sub;\n      ref = this.subscriptions;\n      for (j = 0, len1 = ref.length; j < len1; j++) {\n        sub = ref[j];\n        if (typeof sub.unsub === \"function\") {\n          sub.unsub();\n        }\n      }\n      return void 0;\n    };\n\n    Bus.prototype.subscribeAll = function(newSink) {\n      var j, len1, ref, subscription;\n      if (this.ended) {\n        newSink(endEvent());\n      } else {\n        this.sink = newSink;\n        ref = cloneArray(this.subscriptions);\n        for (j = 0, len1 = ref.length; j < len1; j++) {\n          subscription = ref[j];\n          this.subscribeInput(subscription);\n        }\n      }\n      return this.unsubAll;\n    };\n\n    Bus.prototype.guardedSink = function(input) {\n      return (function(_this) {\n        return function(event) {\n          if (event.isEnd()) {\n            _this.unsubscribeInput(input);\n            return Bacon.noMore;\n          } else {\n            return _this.sink(event);\n          }\n        };\n      })(this);\n    };\n\n    Bus.prototype.subscribeInput = function(subscription) {\n      return subscription.unsub = subscription.input.dispatcher.subscribe(this.guardedSink(subscription.input));\n    };\n\n    Bus.prototype.unsubscribeInput = function(input) {\n      var i, j, len1, ref, sub;\n      ref = this.subscriptions;\n      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n        sub = ref[i];\n        if (sub.input === input) {\n          if (typeof sub.unsub === \"function\") {\n            sub.unsub();\n          }\n          this.subscriptions.splice(i, 1);\n          return;\n        }\n      }\n    };\n\n    Bus.prototype.plug = function(input) {\n      var sub;\n      assertObservable(input);\n      if (this.ended) {\n        return;\n      }\n      sub = {\n        input: input\n      };\n      this.subscriptions.push(sub);\n      if ((this.sink != null)) {\n        this.subscribeInput(sub);\n      }\n      return (function(_this) {\n        return function() {\n          return _this.unsubscribeInput(input);\n        };\n      })(this);\n    };\n\n    Bus.prototype.end = function() {\n      this.ended = true;\n      this.unsubAll();\n      return typeof this.sink === \"function\" ? this.sink(endEvent()) : void 0;\n    };\n\n    Bus.prototype.push = function(value) {\n      if (!this.ended) {\n        return typeof this.sink === \"function\" ? this.sink(nextEvent(value)) : void 0;\n      }\n    };\n\n    Bus.prototype.error = function(error) {\n      return typeof this.sink === \"function\" ? this.sink(new Error(error)) : void 0;\n    };\n\n    return Bus;\n\n  })(EventStream);\n\n  Bacon.Bus = Bus;\n\n  liftCallback = function(desc, wrapped) {\n    return withMethodCallSupport(function() {\n      var args, f, stream;\n      f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      stream = partiallyApplied(wrapped, [\n        function(values, callback) {\n          return f.apply(null, slice.call(values).concat([callback]));\n        }\n      ]);\n      return withDesc(new Bacon.Desc(Bacon, desc, [f].concat(slice.call(args))), Bacon.combineAsArray(args).flatMap(stream));\n    });\n  };\n\n  Bacon.fromCallback = liftCallback(\"fromCallback\", function() {\n    var args, f;\n    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return Bacon.fromBinder(function(handler) {\n      makeFunction(f, args)(handler);\n      return nop;\n    }, (function(value) {\n      return [value, endEvent()];\n    }));\n  });\n\n  Bacon.fromNodeCallback = liftCallback(\"fromNodeCallback\", function() {\n    var args, f;\n    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return Bacon.fromBinder(function(handler) {\n      makeFunction(f, args)(handler);\n      return nop;\n    }, function(error, value) {\n      if (error) {\n        return [new Error(error), endEvent()];\n      }\n      return [value, endEvent()];\n    });\n  });\n\n  Bacon.combineTemplate = function(template) {\n    var applyStreamValue, combinator, compile, compileTemplate, constantValue, current, funcs, mkContext, pushContext, setValue, streams;\n    funcs = [];\n    streams = [];\n    current = function(ctxStack) {\n      return ctxStack[ctxStack.length - 1];\n    };\n    setValue = function(ctxStack, key, value) {\n      return current(ctxStack)[key] = value;\n    };\n    applyStreamValue = function(key, index) {\n      return function(ctxStack, values) {\n        return setValue(ctxStack, key, values[index]);\n      };\n    };\n    constantValue = function(key, value) {\n      return function(ctxStack) {\n        return setValue(ctxStack, key, value);\n      };\n    };\n    mkContext = function(template) {\n      if (isArray(template)) {\n        return [];\n      } else {\n        return {};\n      }\n    };\n    pushContext = function(key, value) {\n      return function(ctxStack) {\n        var newContext;\n        newContext = mkContext(value);\n        setValue(ctxStack, key, newContext);\n        return ctxStack.push(newContext);\n      };\n    };\n    compile = function(key, value) {\n      var popContext;\n      if (isObservable(value)) {\n        streams.push(value);\n        return funcs.push(applyStreamValue(key, streams.length - 1));\n      } else if (value === Object(value) && typeof value !== \"function\" && !(value instanceof RegExp) && !(value instanceof Date)) {\n        popContext = function(ctxStack) {\n          return ctxStack.pop();\n        };\n        funcs.push(pushContext(key, value));\n        compileTemplate(value);\n        return funcs.push(popContext);\n      } else {\n        return funcs.push(constantValue(key, value));\n      }\n    };\n    compileTemplate = function(template) {\n      return _.each(template, compile);\n    };\n    compileTemplate(template);\n    combinator = function(values) {\n      var ctxStack, f, j, len1, rootContext;\n      rootContext = mkContext(template);\n      ctxStack = [rootContext];\n      for (j = 0, len1 = funcs.length; j < len1; j++) {\n        f = funcs[j];\n        f(ctxStack, values);\n      }\n      return rootContext;\n    };\n    return withDesc(new Bacon.Desc(Bacon, \"combineTemplate\", [template]), Bacon.combineAsArray(streams).map(combinator));\n  };\n\n  addPropertyInitValueToStream = function(property, stream) {\n    var justInitValue;\n    justInitValue = new EventStream(describe(property, \"justInitValue\"), function(sink) {\n      var unsub, value;\n      value = void 0;\n      unsub = property.dispatcher.subscribe(function(event) {\n        if (!event.isEnd()) {\n          value = event;\n        }\n        return Bacon.noMore;\n      });\n      UpdateBarrier.whenDoneWith(justInitValue, function() {\n        if (value != null) {\n          sink(value);\n        }\n        return sink(endEvent());\n      });\n      return unsub;\n    });\n    return justInitValue.concat(stream).toProperty();\n  };\n\n  Bacon.Observable.prototype.mapEnd = function() {\n    var f;\n    f = makeFunctionArgs(arguments);\n    return withDesc(new Bacon.Desc(this, \"mapEnd\", [f]), this.withHandler(function(event) {\n      if (event.isEnd()) {\n        this.push(nextEvent(f(event)));\n        this.push(endEvent());\n        return Bacon.noMore;\n      } else {\n        return this.push(event);\n      }\n    }));\n  };\n\n  Bacon.Observable.prototype.skipErrors = function() {\n    return withDesc(new Bacon.Desc(this, \"skipErrors\", []), this.withHandler(function(event) {\n      if (event.isError()) {\n        return Bacon.more;\n      } else {\n        return this.push(event);\n      }\n    }));\n  };\n\n  Bacon.EventStream.prototype.takeUntil = function(stopper) {\n    var endMarker;\n    endMarker = {};\n    return withDesc(new Bacon.Desc(this, \"takeUntil\", [stopper]), Bacon.groupSimultaneous(this.mapEnd(endMarker), stopper.skipErrors()).withHandler(function(event) {\n      var data, j, len1, ref, reply, value;\n      if (!event.hasValue()) {\n        return this.push(event);\n      } else {\n        ref = event.value(), data = ref[0], stopper = ref[1];\n        if (stopper.length) {\n          return this.push(endEvent());\n        } else {\n          reply = Bacon.more;\n          for (j = 0, len1 = data.length; j < len1; j++) {\n            value = data[j];\n            if (value === endMarker) {\n              reply = this.push(endEvent());\n            } else {\n              reply = this.push(nextEvent(value));\n            }\n          }\n          return reply;\n        }\n      }\n    }));\n  };\n\n  Bacon.Property.prototype.takeUntil = function(stopper) {\n    var changes;\n    changes = this.changes().takeUntil(stopper);\n    return withDesc(new Bacon.Desc(this, \"takeUntil\", [stopper]), addPropertyInitValueToStream(this, changes));\n  };\n\n  Bacon.Observable.prototype.flatMapLatest = function() {\n    var f, stream;\n    f = makeSpawner(arguments);\n    stream = this.toEventStream();\n    return withDesc(new Bacon.Desc(this, \"flatMapLatest\", [f]), stream.flatMap(function(value) {\n      return makeObservable(f(value)).takeUntil(stream);\n    }));\n  };\n\n  Bacon.Property.prototype.delayChanges = function(desc, f) {\n    return withDesc(desc, addPropertyInitValueToStream(this, f(this.changes())));\n  };\n\n  Bacon.EventStream.prototype.delay = function(delay) {\n    return withDesc(new Bacon.Desc(this, \"delay\", [delay]), this.flatMap(function(value) {\n      return Bacon.later(delay, value);\n    }));\n  };\n\n  Bacon.Property.prototype.delay = function(delay) {\n    return this.delayChanges(new Bacon.Desc(this, \"delay\", [delay]), function(changes) {\n      return changes.delay(delay);\n    });\n  };\n\n  Bacon.EventStream.prototype.debounce = function(delay) {\n    return withDesc(new Bacon.Desc(this, \"debounce\", [delay]), this.flatMapLatest(function(value) {\n      return Bacon.later(delay, value);\n    }));\n  };\n\n  Bacon.Property.prototype.debounce = function(delay) {\n    return this.delayChanges(new Bacon.Desc(this, \"debounce\", [delay]), function(changes) {\n      return changes.debounce(delay);\n    });\n  };\n\n  Bacon.EventStream.prototype.debounceImmediate = function(delay) {\n    return withDesc(new Bacon.Desc(this, \"debounceImmediate\", [delay]), this.flatMapFirst(function(value) {\n      return Bacon.once(value).concat(Bacon.later(delay).filter(false));\n    }));\n  };\n\n  Bacon.Observable.prototype.decode = function(cases) {\n    return withDesc(new Bacon.Desc(this, \"decode\", [cases]), this.combine(Bacon.combineTemplate(cases), function(key, values) {\n      return values[key];\n    }));\n  };\n\n  Bacon.Observable.prototype.scan = function(seed, f) {\n    var acc, initHandled, resultProperty, subscribe;\n    f = toCombinator(f);\n    acc = toOption(seed);\n    initHandled = false;\n    subscribe = (function(_this) {\n      return function(sink) {\n        var initSent, reply, sendInit, unsub;\n        initSent = false;\n        unsub = nop;\n        reply = Bacon.more;\n        sendInit = function() {\n          if (!initSent) {\n            return acc.forEach(function(value) {\n              initSent = initHandled = true;\n              reply = sink(new Initial(function() {\n                return value;\n              }));\n              if (reply === Bacon.noMore) {\n                unsub();\n                return unsub = nop;\n              }\n            });\n          }\n        };\n        unsub = _this.dispatcher.subscribe(function(event) {\n          var next, prev;\n          if (event.hasValue()) {\n            if (initHandled && event.isInitial()) {\n              return Bacon.more;\n            } else {\n              if (!event.isInitial()) {\n                sendInit();\n              }\n              initSent = initHandled = true;\n              prev = acc.getOrElse(void 0);\n              next = f(prev, event.value());\n              acc = new Some(next);\n              return sink(event.apply(function() {\n                return next;\n              }));\n            }\n          } else {\n            if (event.isEnd()) {\n              reply = sendInit();\n            }\n            if (reply !== Bacon.noMore) {\n              return sink(event);\n            }\n          }\n        });\n        UpdateBarrier.whenDoneWith(resultProperty, sendInit);\n        return unsub;\n      };\n    })(this);\n    return resultProperty = new Property(new Bacon.Desc(this, \"scan\", [seed, f]), subscribe);\n  };\n\n  Bacon.Observable.prototype.diff = function(start, f) {\n    f = toCombinator(f);\n    return withDesc(new Bacon.Desc(this, \"diff\", [start, f]), this.scan([start], function(prevTuple, next) {\n      return [next, f(prevTuple[0], next)];\n    }).filter(function(tuple) {\n      return tuple.length === 2;\n    }).map(function(tuple) {\n      return tuple[1];\n    }));\n  };\n\n  Bacon.Observable.prototype.doAction = function() {\n    var f;\n    f = makeFunctionArgs(arguments);\n    return withDesc(new Bacon.Desc(this, \"doAction\", [f]), this.withHandler(function(event) {\n      if (event.hasValue()) {\n        f(event.value());\n      }\n      return this.push(event);\n    }));\n  };\n\n  Bacon.Observable.prototype.doError = function() {\n    var f;\n    f = makeFunctionArgs(arguments);\n    return withDesc(new Bacon.Desc(this, \"doError\", [f]), this.withHandler(function(event) {\n      if (event.isError()) {\n        f(event.error);\n      }\n      return this.push(event);\n    }));\n  };\n\n  Bacon.Observable.prototype.doLog = function() {\n    var args;\n    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return withDesc(new Bacon.Desc(this, \"doLog\", args), this.withHandler(function(event) {\n      if (typeof console !== \"undefined\" && console !== null) {\n        if (typeof console.log === \"function\") {\n          console.log.apply(console, slice.call(args).concat([event.log()]));\n        }\n      }\n      return this.push(event);\n    }));\n  };\n\n  Bacon.Observable.prototype.endOnError = function() {\n    var args, f;\n    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    if (f == null) {\n      f = true;\n    }\n    return convertArgsToFunction(this, f, args, function(f) {\n      return withDesc(new Bacon.Desc(this, \"endOnError\", []), this.withHandler(function(event) {\n        if (event.isError() && f(event.error)) {\n          this.push(event);\n          return this.push(endEvent());\n        } else {\n          return this.push(event);\n        }\n      }));\n    });\n  };\n\n  Observable.prototype.errors = function() {\n    return withDesc(new Bacon.Desc(this, \"errors\", []), this.filter(function() {\n      return false;\n    }));\n  };\n\n  valueAndEnd = (function(value) {\n    return [value, endEvent()];\n  });\n\n  Bacon.fromPromise = function(promise, abort, eventTransformer) {\n    if (eventTransformer == null) {\n      eventTransformer = valueAndEnd;\n    }\n    return withDesc(new Bacon.Desc(Bacon, \"fromPromise\", [promise]), Bacon.fromBinder(function(handler) {\n      var ref;\n      if ((ref = promise.then(handler, function(e) {\n        return handler(new Error(e));\n      })) != null) {\n        if (typeof ref.done === \"function\") {\n          ref.done();\n        }\n      }\n      return function() {\n        if (abort) {\n          return typeof promise.abort === \"function\" ? promise.abort() : void 0;\n        }\n      };\n    }, eventTransformer));\n  };\n\n  Bacon.Observable.prototype.mapError = function() {\n    var f;\n    f = makeFunctionArgs(arguments);\n    return withDesc(new Bacon.Desc(this, \"mapError\", [f]), this.withHandler(function(event) {\n      if (event.isError()) {\n        return this.push(nextEvent(f(event.error)));\n      } else {\n        return this.push(event);\n      }\n    }));\n  };\n\n  Bacon.Observable.prototype.flatMapError = function(fn) {\n    return withDesc(new Bacon.Desc(this, \"flatMapError\", [fn]), this.mapError(function(err) {\n      return new Error(err);\n    }).flatMap(function(x) {\n      if (x instanceof Error) {\n        return fn(x.error);\n      } else {\n        return Bacon.once(x);\n      }\n    }));\n  };\n\n  Bacon.EventStream.prototype.sampledBy = function(sampler, combinator) {\n    return withDesc(new Bacon.Desc(this, \"sampledBy\", [sampler, combinator]), this.toProperty().sampledBy(sampler, combinator));\n  };\n\n  Bacon.Property.prototype.sampledBy = function(sampler, combinator) {\n    var lazy, result, samplerSource, stream, thisSource;\n    if (combinator != null) {\n      combinator = toCombinator(combinator);\n    } else {\n      lazy = true;\n      combinator = function(f) {\n        return f.value();\n      };\n    }\n    thisSource = new Source(this, false, lazy);\n    samplerSource = new Source(sampler, true, lazy);\n    stream = Bacon.when([thisSource, samplerSource], combinator);\n    result = sampler instanceof Property ? stream.toProperty() : stream;\n    return withDesc(new Bacon.Desc(this, \"sampledBy\", [sampler, combinator]), result);\n  };\n\n  Bacon.Property.prototype.sample = function(interval) {\n    return withDesc(new Bacon.Desc(this, \"sample\", [interval]), this.sampledBy(Bacon.interval(interval, {})));\n  };\n\n  Bacon.Observable.prototype.map = function() {\n    var args, p;\n    p = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    if (p instanceof Property) {\n      return p.sampledBy(this, former);\n    } else {\n      return convertArgsToFunction(this, p, args, function(f) {\n        return withDesc(new Bacon.Desc(this, \"map\", [f]), this.withHandler(function(event) {\n          return this.push(event.fmap(f));\n        }));\n      });\n    }\n  };\n\n  Bacon.Observable.prototype.fold = function(seed, f) {\n    return withDesc(new Bacon.Desc(this, \"fold\", [seed, f]), this.scan(seed, f).sampledBy(this.filter(false).mapEnd().toProperty()));\n  };\n\n  Observable.prototype.reduce = Observable.prototype.fold;\n\n  Bacon.fromPoll = function(delay, poll) {\n    return withDesc(new Bacon.Desc(Bacon, \"fromPoll\", [delay, poll]), Bacon.fromBinder((function(handler) {\n      var id;\n      id = Bacon.scheduler.setInterval(handler, delay);\n      return function() {\n        return Bacon.scheduler.clearInterval(id);\n      };\n    }), poll));\n  };\n\n  Bacon.Observable.prototype.groupBy = function(keyF, limitF) {\n    var src, streams;\n    if (limitF == null) {\n      limitF = Bacon._.id;\n    }\n    streams = {};\n    src = this;\n    return src.filter(function(x) {\n      return !streams[keyF(x)];\n    }).map(function(x) {\n      var data, key, limited, similar;\n      key = keyF(x);\n      similar = src.filter(function(x) {\n        return keyF(x) === key;\n      });\n      data = Bacon.once(x).concat(similar);\n      limited = limitF(data, x).withHandler(function(event) {\n        this.push(event);\n        if (event.isEnd()) {\n          return delete streams[key];\n        }\n      });\n      return streams[key] = limited;\n    });\n  };\n\n  Bacon.fromArray = function(values) {\n    var i;\n    assertArray(values);\n    if (!values.length) {\n      return withDesc(new Bacon.Desc(Bacon, \"fromArray\", values), Bacon.never());\n    } else {\n      i = 0;\n      return new EventStream(new Bacon.Desc(Bacon, \"fromArray\", [values]), function(sink) {\n        var push, pushNeeded, pushing, reply, unsubd;\n        unsubd = false;\n        reply = Bacon.more;\n        pushing = false;\n        pushNeeded = false;\n        push = function() {\n          var value;\n          pushNeeded = true;\n          if (pushing) {\n            return;\n          }\n          pushing = true;\n          while (pushNeeded) {\n            pushNeeded = false;\n            if ((reply !== Bacon.noMore) && !unsubd) {\n              value = values[i++];\n              reply = sink(toEvent(value));\n              if (reply !== Bacon.noMore) {\n                if (i === values.length) {\n                  sink(endEvent());\n                } else {\n                  UpdateBarrier.afterTransaction(push);\n                }\n              }\n            }\n          }\n          return pushing = false;\n        };\n        push();\n        return function() {\n          return unsubd = true;\n        };\n      });\n    }\n  };\n\n  Bacon.EventStream.prototype.holdWhen = function(valve) {\n    var bufferedValues, onHold, src;\n    onHold = false;\n    bufferedValues = [];\n    src = this;\n    return new EventStream(new Bacon.Desc(this, \"holdWhen\", [valve]), function(sink) {\n      var composite, endIfBothEnded, subscribed;\n      composite = new CompositeUnsubscribe();\n      subscribed = false;\n      endIfBothEnded = function(unsub) {\n        if (typeof unsub === \"function\") {\n          unsub();\n        }\n        if (composite.empty() && subscribed) {\n          return sink(endEvent());\n        }\n      };\n      composite.add(function(unsubAll, unsubMe) {\n        return valve.subscribeInternal(function(event) {\n          var j, len1, results, toSend, value;\n          if (event.hasValue()) {\n            onHold = event.value();\n            if (!onHold) {\n              toSend = bufferedValues;\n              bufferedValues = [];\n              results = [];\n              for (j = 0, len1 = toSend.length; j < len1; j++) {\n                value = toSend[j];\n                results.push(sink(nextEvent(value)));\n              }\n              return results;\n            }\n          } else if (event.isEnd()) {\n            return endIfBothEnded(unsubMe);\n          } else {\n            return sink(event);\n          }\n        });\n      });\n      composite.add(function(unsubAll, unsubMe) {\n        return src.subscribeInternal(function(event) {\n          if (onHold && event.hasValue()) {\n            return bufferedValues.push(event.value());\n          } else if (event.isEnd() && bufferedValues.length) {\n            return endIfBothEnded(unsubMe);\n          } else {\n            return sink(event);\n          }\n        });\n      });\n      subscribed = true;\n      endIfBothEnded();\n      return composite.unsubscribe;\n    });\n  };\n\n  Bacon.interval = function(delay, value) {\n    if (value == null) {\n      value = {};\n    }\n    return withDesc(new Bacon.Desc(Bacon, \"interval\", [delay, value]), Bacon.fromPoll(delay, function() {\n      return nextEvent(value);\n    }));\n  };\n\n  Bacon.$ = {};\n\n  Bacon.$.asEventStream = function(eventName, selector, eventTransformer) {\n    var ref;\n    if (_.isFunction(selector)) {\n      ref = [selector, void 0], eventTransformer = ref[0], selector = ref[1];\n    }\n    return withDesc(new Bacon.Desc(this.selector || this, \"asEventStream\", [eventName]), Bacon.fromBinder((function(_this) {\n      return function(handler) {\n        _this.on(eventName, selector, handler);\n        return function() {\n          return _this.off(eventName, selector, handler);\n        };\n      };\n    })(this), eventTransformer));\n  };\n\n  if ((ref = typeof jQuery !== \"undefined\" && jQuery !== null ? jQuery : typeof Zepto !== \"undefined\" && Zepto !== null ? Zepto : void 0) != null) {\n    ref.fn.asEventStream = Bacon.$.asEventStream;\n  }\n\n  Bacon.Observable.prototype.log = function() {\n    var args;\n    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    this.subscribe(function(event) {\n      return typeof console !== \"undefined\" && console !== null ? typeof console.log === \"function\" ? console.log.apply(console, slice.call(args).concat([event.log()])) : void 0 : void 0;\n    });\n    return this;\n  };\n\n  Bacon.EventStream.prototype.merge = function(right) {\n    var left;\n    assertEventStream(right);\n    left = this;\n    return withDesc(new Bacon.Desc(left, \"merge\", [right]), Bacon.mergeAll(this, right));\n  };\n\n  Bacon.mergeAll = function() {\n    var streams;\n    streams = argumentsToObservables(arguments);\n    if (streams.length) {\n      return new EventStream(new Bacon.Desc(Bacon, \"mergeAll\", streams), function(sink) {\n        var ends, sinks, smartSink;\n        ends = 0;\n        smartSink = function(obs) {\n          return function(unsubBoth) {\n            return obs.dispatcher.subscribe(function(event) {\n              var reply;\n              if (event.isEnd()) {\n                ends++;\n                if (ends === streams.length) {\n                  return sink(endEvent());\n                } else {\n                  return Bacon.more;\n                }\n              } else {\n                reply = sink(event);\n                if (reply === Bacon.noMore) {\n                  unsubBoth();\n                }\n                return reply;\n              }\n            });\n          };\n        };\n        sinks = _.map(smartSink, streams);\n        return new Bacon.CompositeUnsubscribe(sinks).unsubscribe;\n      });\n    } else {\n      return Bacon.never();\n    }\n  };\n\n  Bacon.repeatedly = function(delay, values) {\n    var index;\n    index = 0;\n    return withDesc(new Bacon.Desc(Bacon, \"repeatedly\", [delay, values]), Bacon.fromPoll(delay, function() {\n      return values[index++ % values.length];\n    }));\n  };\n\n  Bacon.repeat = function(generator) {\n    var index;\n    index = 0;\n    return Bacon.fromBinder(function(sink) {\n      var flag, handleEvent, reply, subscribeNext, unsub;\n      flag = false;\n      reply = Bacon.more;\n      unsub = function() {};\n      handleEvent = function(event) {\n        if (event.isEnd()) {\n          if (!flag) {\n            return flag = true;\n          } else {\n            return subscribeNext();\n          }\n        } else {\n          return reply = sink(event);\n        }\n      };\n      subscribeNext = function() {\n        var next;\n        flag = true;\n        while (flag && reply !== Bacon.noMore) {\n          next = generator(index++);\n          flag = false;\n          if (next) {\n            unsub = next.subscribeInternal(handleEvent);\n          } else {\n            sink(endEvent());\n          }\n        }\n        return flag = true;\n      };\n      subscribeNext();\n      return function() {\n        return unsub();\n      };\n    });\n  };\n\n  Bacon.retry = function(options) {\n    var delay, error, finished, isRetryable, maxRetries, retries, source;\n    if (!_.isFunction(options.source)) {\n      throw new Exception(\"'source' option has to be a function\");\n    }\n    source = options.source;\n    retries = options.retries || 0;\n    maxRetries = options.maxRetries || retries;\n    delay = options.delay || function() {\n      return 0;\n    };\n    isRetryable = options.isRetryable || function() {\n      return true;\n    };\n    finished = false;\n    error = null;\n    return withDesc(new Bacon.Desc(Bacon, \"retry\", [options]), Bacon.repeat(function() {\n      var context, pause, valueStream;\n      if (finished) {\n        return null;\n      } else {\n        valueStream = function() {\n          return source().endOnError().withHandler(function(event) {\n            if (event.isError()) {\n              error = event;\n              if (isRetryable(error.error) && retries > 0) {\n\n              } else {\n                finished = true;\n                return this.push(event);\n              }\n            } else {\n              if (event.hasValue()) {\n                error = null;\n                finished = true;\n              }\n              return this.push(event);\n            }\n          });\n        };\n        if (error) {\n          context = {\n            error: error.error,\n            retriesDone: maxRetries - retries\n          };\n          pause = Bacon.later(delay(context)).filter(false);\n          retries = retries - 1;\n          return pause.concat(Bacon.once().flatMap(valueStream));\n        } else {\n          return valueStream();\n        }\n      }\n    }));\n  };\n\n  Bacon.sequentially = function(delay, values) {\n    var index;\n    index = 0;\n    return withDesc(new Bacon.Desc(Bacon, \"sequentially\", [delay, values]), Bacon.fromPoll(delay, function() {\n      var value;\n      value = values[index++];\n      if (index < values.length) {\n        return value;\n      } else if (index === values.length) {\n        return [value, endEvent()];\n      } else {\n        return endEvent();\n      }\n    }));\n  };\n\n  Bacon.Observable.prototype.skip = function(count) {\n    return withDesc(new Bacon.Desc(this, \"skip\", [count]), this.withHandler(function(event) {\n      if (!event.hasValue()) {\n        return this.push(event);\n      } else if (count > 0) {\n        count--;\n        return Bacon.more;\n      } else {\n        return this.push(event);\n      }\n    }));\n  };\n\n  Bacon.Observable.prototype.take = function(count) {\n    if (count <= 0) {\n      return Bacon.never();\n    }\n    return withDesc(new Bacon.Desc(this, \"take\", [count]), this.withHandler(function(event) {\n      if (!event.hasValue()) {\n        return this.push(event);\n      } else {\n        count--;\n        if (count > 0) {\n          return this.push(event);\n        } else {\n          if (count === 0) {\n            this.push(event);\n          }\n          this.push(endEvent());\n          return Bacon.noMore;\n        }\n      }\n    }));\n  };\n\n  Bacon.EventStream.prototype.skipUntil = function(starter) {\n    var started;\n    started = starter.take(1).map(true).toProperty(false);\n    return withDesc(new Bacon.Desc(this, \"skipUntil\", [starter]), this.filter(started));\n  };\n\n  Bacon.EventStream.prototype.skipWhile = function() {\n    var args, f, ok;\n    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    assertObservableIsProperty(f);\n    ok = false;\n    return convertArgsToFunction(this, f, args, function(f) {\n      return withDesc(new Bacon.Desc(this, \"skipWhile\", [f]), this.withHandler(function(event) {\n        if (ok || !event.hasValue() || !f(event.value())) {\n          if (event.hasValue()) {\n            ok = true;\n          }\n          return this.push(event);\n        } else {\n          return Bacon.more;\n        }\n      }));\n    });\n  };\n\n  Bacon.Observable.prototype.slidingWindow = function(n, minValues) {\n    if (minValues == null) {\n      minValues = 0;\n    }\n    return withDesc(new Bacon.Desc(this, \"slidingWindow\", [n, minValues]), this.scan([], (function(window, value) {\n      return window.concat([value]).slice(-n);\n    })).filter((function(values) {\n      return values.length >= minValues;\n    })));\n  };\n\n  Bacon.spy = function(spy) {\n    return spys.push(spy);\n  };\n\n  spys = [];\n\n  registerObs = function(obs) {\n    var j, len1, spy;\n    if (spys.length) {\n      if (!registerObs.running) {\n        try {\n          registerObs.running = true;\n          for (j = 0, len1 = spys.length; j < len1; j++) {\n            spy = spys[j];\n            spy(obs);\n          }\n        } finally {\n          delete registerObs.running;\n        }\n      }\n    }\n    return void 0;\n  };\n\n  Bacon.Property.prototype.startWith = function(seed) {\n    return withDesc(new Bacon.Desc(this, \"startWith\", [seed]), this.scan(seed, function(prev, next) {\n      return next;\n    }));\n  };\n\n  Bacon.EventStream.prototype.startWith = function(seed) {\n    return withDesc(new Bacon.Desc(this, \"startWith\", [seed]), Bacon.once(seed).concat(this));\n  };\n\n  Bacon.Observable.prototype.takeWhile = function() {\n    var args, f;\n    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    assertObservableIsProperty(f);\n    return convertArgsToFunction(this, f, args, function(f) {\n      return withDesc(new Bacon.Desc(this, \"takeWhile\", [f]), this.withHandler(function(event) {\n        if (event.filter(f)) {\n          return this.push(event);\n        } else {\n          this.push(endEvent());\n          return Bacon.noMore;\n        }\n      }));\n    });\n  };\n\n  Bacon.update = function() {\n    var i, initial, lateBindFirst, patterns;\n    initial = arguments[0], patterns = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    lateBindFirst = function(f) {\n      return function() {\n        var args;\n        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        return function(i) {\n          return f.apply(null, [i].concat(args));\n        };\n      };\n    };\n    i = patterns.length - 1;\n    while (i > 0) {\n      if (!(patterns[i] instanceof Function)) {\n        patterns[i] = (function(x) {\n          return function() {\n            return x;\n          };\n        })(patterns[i]);\n      }\n      patterns[i] = lateBindFirst(patterns[i]);\n      i = i - 2;\n    }\n    return withDesc(new Bacon.Desc(Bacon, \"update\", [initial].concat(slice.call(patterns))), Bacon.when.apply(Bacon, patterns).scan(initial, (function(x, f) {\n      return f(x);\n    })));\n  };\n\n  Bacon.zipAsArray = function() {\n    var streams;\n    streams = argumentsToObservables(arguments);\n    return withDesc(new Bacon.Desc(Bacon, \"zipAsArray\", streams), Bacon.zipWith(streams, function() {\n      var xs;\n      xs = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return xs;\n    }));\n  };\n\n  Bacon.zipWith = function() {\n    var f, ref1, streams;\n    ref1 = argumentsToObservablesAndFunction(arguments), streams = ref1[0], f = ref1[1];\n    streams = _.map((function(s) {\n      return s.toEventStream();\n    }), streams);\n    return withDesc(new Bacon.Desc(Bacon, \"zipWith\", [f].concat(slice.call(streams))), Bacon.when(streams, f));\n  };\n\n  Bacon.Observable.prototype.zip = function(other, f) {\n    if (f == null) {\n      f = Array;\n    }\n    return withDesc(new Bacon.Desc(this, \"zip\", [other]), Bacon.zipWith([this, other], f));\n  };\n\n  \n\nBacon.Observable.prototype.first = function () {\n  return withDesc(new Bacon.Desc(this, \"first\", []), this.take(1));\n};\n\nBacon.Observable.prototype.last = function () {\n  var lastEvent;\n\n  return withDesc(new Bacon.Desc(this, \"last\", []), this.withHandler(function (event) {\n    if (event.isEnd()) {\n      if (lastEvent) {\n        this.push(lastEvent);\n      }\n      this.push(endEvent());\n      return Bacon.noMore;\n    } else {\n      lastEvent = event;\n    }\n  }));\n};\n\nBacon.EventStream.prototype.throttle = function (delay) {\n  return withDesc(new Bacon.Desc(this, \"throttle\", [delay]), this.bufferWithTime(delay).map(function (values) {\n    return values[values.length - 1];\n  }));\n};\n\nBacon.Property.prototype.throttle = function (delay) {\n  return this.delayChanges(new Bacon.Desc(this, \"throttle\", [delay]), function (changes) {\n    return changes.throttle(delay);\n  });\n};\n\nObservable.prototype.firstToPromise = function (PromiseCtr) {\n  var _this = this;\n\n  if (typeof PromiseCtr !== \"function\") {\n    if (typeof Promise === \"function\") {\n      PromiseCtr = Promise;\n    } else {\n      throw new Exception(\"There isn't default Promise, use shim or parameter\");\n    }\n  }\n\n  return new PromiseCtr(function (resolve, reject) {\n    return _this.subscribe(function (event) {\n      if (event.hasValue()) {\n        resolve(event.value());\n      }\n      if (event.isError()) {\n        reject(event.error);\n      }\n\n      return Bacon.noMore;\n    });\n  });\n};\n\nObservable.prototype.toPromise = function (PromiseCtr) {\n  return this.last().firstToPromise(PromiseCtr);\n};\n\nif ((typeof define !== \"undefined\" && define !== null) && (define.amd != null)) {\n    define([], function() {\n      return Bacon;\n    });\n    this.Bacon = Bacon;\n  } else if ((typeof module !== \"undefined\" && module !== null) && (module.exports != null)) {\n    module.exports = Bacon;\n    Bacon.Bacon = Bacon;\n  } else {\n    this.Bacon = Bacon;\n  }\n\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baconjs/dist/Bacon.js\n ** module id = 36\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 37\n ** module chunks = 0\n **/","module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-define.js\n ** module id = 38\n ** module chunks = 0\n **/","module.exports = __webpack_amd_options__;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-options.js\n ** module id = 39\n ** module chunks = 0\n **/","// Copyright (c) 2013-2014 Quildreen Motta <quildreen@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = require('./future')\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/data.future/lib/index.js\n ** module id = 40\n ** module chunks = 0\n **/","// Copyright (c) 2013-2014 Quildreen Motta <quildreen@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module lib/future\n */\nmodule.exports = Future\n\n\n// -- Dependencies -----------------------------------------------------\nvar memoisedFork = require('./memoised').memoisedFork\n\n\n// -- Implementation ---------------------------------------------------\n\n/**\n * The `Future[α, β]` structure represents values that depend on time. This\n * allows one to model time-based effects explicitly, such that one can have\n * full knowledge of when they're dealing with delayed computations, latency,\n * or anything that can not be computed immediately.\n *\n * A common use for this structure is to replace the usual Continuation-Passing\n * Style form of programming, in order to be able to compose and sequence\n * time-dependent effects using the generic and powerful monadic operations.\n *\n * @class\n * @summary\n * ((α → Void), (β → Void) → Void), (Void → Void) → Future[α, β]\n *\n * Future[α, β] <: Chain[β]\n *               , Monad[β]\n *               , Functor[β]\n *               , Applicative[β]\n *               , Semigroup[β]\n *               , Monoid[β]\n *               , Show\n */\nfunction Future(computation, cleanup) {\n  this.fork    = computation\n  this.cleanup = cleanup || function(){ }\n}\n\n/**\n * Creates a `Future[α, β]` that computes the action at most once.\n *\n * Since this function will remember the resolved value of the future, **it's\n * expected to be used only for pure actions,** otherwise you may not be able\n * to observe the effects.\n *\n * @summary ((α → Void), (β → Void) → Void) → Future[α, β]\n */\nFuture.prototype.memoise = function _memoise(f) {\n  if (typeof console !== 'undefined')\n    console.warn(\"Future#memoise is deprecated. Use control.async's memoise() function instead.\")\n\n  var future  = new Future()\n  future.fork = memoisedFork(f, future)\n  return future\n}\nFuture.memoise = Future.prototype.memoise\n\n\n/**\n * Constructs a new `Future[α, β]` containing the single value `β`.\n *\n * `β` can be any value, including `null`, `undefined`, or another\n * `Future[α, β]` structure.\n *\n * @summary β → Future[α, β]\n */\nFuture.prototype.of = function _of(b) {\n  return new Future(function(_, resolve){ return resolve(b) })\n}\nFuture.of = Future.prototype.of\n\n\n/**\n * Constructs a new `Future[α, β]` containing the single value `α`.\n * \n * `α` can be any value, including `null`, `undefined`, or another \n * `Future[α, β]` structure.\n * \n * @summary α → Future[α, β]\n */\nFuture.prototype.rejected = function _rejected(a) {\n  return new Future(function(reject, _){ return reject(a) })\n}\nFuture.rejected = Future.prototype.rejected\n\n\n// -- Functor ----------------------------------------------------------\n\n/**\n * Transforms the successful value of the `Future[α, β]` using a regular unary\n * function.\n *\n * @summary @Future[α, β] => (β → γ) → Future[α, γ]\n */\nFuture.prototype.map = function _map(f) {\n  return this.chain(function(a){\n                      var result = Future.of(f(a))\n                      result.cleanup = this.cleanup || function(){ }\n                      return result\n                    }.bind(this))\n}\n\n\n// -- Chain ------------------------------------------------------------\n\n/**\n * Transforms the succesful value of the `Future[α, β]` using a function to a\n * monad.\n *\n * @summary @Future[α, β] => (β → Future[α, γ]) → Future[α, γ]\n */\nFuture.prototype.chain = function _chain(f) {\n  return new Future(function(reject, resolve) {\n                      return this.fork( function(a){\n                                          return reject(a) }\n                                      , function(b){\n                                          return f(b).fork(reject, resolve) })\n                    }.bind(this), this.cleanup)\n}\n\n\n// -- Apply ------------------------------------------------------------\n\n/**\n * Applys the successful value of the `Future[α, (β → γ)]` to the successful\n * value of the `Future[α, β]`\n *\n * @summary @Future[α, (β → γ)] => Future[α, β] → Future[α, γ]\n */\n\nFuture.prototype.ap = function _ap(f2) {\n  return this.chain(function(f) { return f2.map(f) })\n}\n\n\n// -- Semigroup ------------------------------------------------------------\n\n/**\n * Selects the earlier of the two futures `Future[α, β]`\n *\n * @summary @Future[α, β] => Future[α, β] → Future[α, β]\n */\n\nFuture.prototype.concat = function _concat(f2) {\n  var done    = false\n\n  return new Future(function(reject, resolve) {\n    return this.fork(runIfNotDone(reject, f2), runIfNotDone(resolve, f2))\n        || f2.fork(runIfNotDone(reject, this), runIfNotDone(resolve, this))\n  }.bind(this), cleanupAll.bind(this))\n\n  function cleanupAll() {\n    this.cleanup()\n    f2.cleanup()\n  }\n\n  function runIfNotDone(f, other){ return function(x) {\n    if (!done) {\n      done = true\n      other.cleanup()\n      return f(x) }}}\n}\n\n\n// -- Monoid ------------------------------------------------------------\n\n/**\n * Returns a Future that will never resolve\n *\n * @summary Void → Future[α, _]\n */\nFuture.empty = function _empty() {\n  return new Future(function(rej, res){ /* never resolve */ })\n}\n\nFuture.prototype.empty = Future.empty\n\n\n// -- Show -------------------------------------------------------------\n\n/**\n * Returns a textual representation of the `Future[α, β]`\n *\n * @summary @Future[α, β] => Void → String\n */\nFuture.prototype.toString = function _toString() {\n  return 'Future'\n}\n\n\n// -- Extracting and recovering ----------------------------------------\n\n/**\n * Transforms a failure value into a new `Future[α, β]`. Does nothing if the\n * structure already contains a successful value.\n *\n * @summary @Future[α, β] => (α → Future[γ, β]) → Future[γ, β]\n */\nFuture.prototype.orElse = function _orElse(f) {\n  return new Future(function(reject, resolve) {\n                      return this.fork( function(a){\n                                          return f(a).fork(reject, resolve) }\n                                      , function(b){\n                                          return resolve(b) })\n                    }.bind(this), this.cleanup)\n}\n\n\n// -- Folds and extended transformations -------------------------------\n\n/**\n * Catamorphism. Takes two functions, applies the leftmost one to the failure\n * value, and the rightmost one to the successful value, depending on which one\n * is present.\n *\n * @summary @Future[α, β] => (α → γ), (β → γ) → Future[δ, γ]\n */\nFuture.prototype.fold = function _fold(f, g) {\n  return new Future(function(reject, resolve) {\n                      return this.fork( function(a){\n                                          return resolve(f(a)) }\n                                      , function(b){\n                                          return resolve(g(b)) })\n                    }.bind(this), this.cleanup)\n}\n\n/**\n * Catamorphism.\n * \n * @summary @Future[α, β] => { Rejected: α → γ, Resolved: β → γ } → Future[δ, γ]\n */\nFuture.prototype.cata = function _cata(pattern) {\n  return this.fold(pattern.Rejected, pattern.Resolved)\n}\n\n/**\n * Swaps the disjunction values.\n *\n * @summary @Future[α, β] => Void → Future[β, α]\n */\nFuture.prototype.swap = function _swap() {\n  return new Future(function(reject, resolve) {\n                      return this.fork( function(a){\n                                          return resolve(a) }\n                                      , function(b){\n                                          return reject(b) })\n                    }.bind(this), this.cleanup)\n}\n\n/**\n * Maps both sides of the disjunction.\n *\n * @summary @Future[α, β] => (α → γ), (β → δ) → Future[γ, δ]\n */\nFuture.prototype.bimap = function _bimap(f, g) {\n  return new Future(function(reject, resolve) {\n                      return this.fork( function(a){\n                                          return reject(f(a)) }\n                                      , function(b){\n                                          return resolve(g(b)) })\n                    }.bind(this), this.cleanup)\n}\n\n/**\n * Maps the left side of the disjunction (failure).\n *\n * @summary @Future[α, β] => (α → γ) → Future[γ, β]\n */\nFuture.prototype.rejectedMap = function _rejectedMap(f) {\n  return new Future(function(reject, resolve) {\n                      return this.fork( function(a){\n                                          return reject(f(a)) }\n                                      , function(b){\n                                          return resolve(b) })\n                    }.bind(this), this.cleanup)\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/data.future/lib/future.js\n ** module id = 41\n ** module chunks = 0\n **/","// Copyright (c) 2013-2014 Quildreen Motta <quildreen@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module lib/memoised\n */\n\n/**\n * A function that memoises the result of a future operation, for performance\n * of pure futures.\n *\n * @method\n * @summary ((α → Void), (β → Void) → Void), Future[α, β] → ((α → Void), (β → Void) → Void)\n */\nexports.memoisedFork = memoisedFork\nfunction memoisedFork(f, future) {\n  var pending  = []\n  var started  = false\n  var resolved = false\n  var rejected = false\n  var value    = null\n\n  return fold\n\n  // The fold applies the correct operation to the future's value, if the\n  // future has been resolved. Or we run the operation instead.\n  //\n  // For optimisation purposes, we cache the result of the operation, so\n  // if we started an operation before, we mark it as started and push\n  // any subsequent forks into a pending queue that will be invoked once\n  // the original fork returns.\n  function fold(g, h) {\n    return resolved?        h(value)\n    :      rejected?        g(value)\n    :      started?         addToPendingOperations(g, h)\n    :      /* otherwise */  resolveFuture(g, h)\n  }\n\n  // Remembers some operation to fire at a later point in time, when the\n  // future gets resolved\n  function addToPendingOperations(g, h) {\n    pending.push({ rejected: g, resolved: h })\n  }\n\n  // Resolves the future, and memorises its value and resolution strategy\n  function resolveFuture(g, h) {\n    started = true\n    return f( function(a) { rejected     = true\n                            value = a\n                            invokePending('rejected', a)\n                            return g(a) }\n\n            , function(b) { resolved     = true\n                            value = b\n                            invokePending('resolved', b)\n                            return h(b) })\n  }\n\n  // Invokes operations that were added before the future got a value\n  function invokePending(kind, value) {\n    var xs = pending\n    started        = false\n    pending.length = 0\n\n    for (var i = 0; i < xs.length; ++i)  xs[i][kind](value)\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/data.future/lib/memoised.js\n ** module id = 42\n ** module chunks = 0\n **/","export const runIO = function(io) {\n    return io.val();\n};\n\nexport const IOType = function(fn) {\n    this.val = fn;\n    this.runIO = this.val;\n};\n\nexport const IO = function(fn) {\n    return (new IOType(fn));\n};\n\nIOType.of = function(x) {\n    return IO(function() {\n        return x;\n    });\n};\nIOType.prototype.of = IOType.of;\n\nIOType.prototype.chain = function(g) {\n    var io = this;\n    return IO(function() {\n        return g(io.val()).val();\n    });\n};\n\n// Derived\nIOType.prototype.map = function(f) {\n    return this.chain(function(a) {\n        return IOType.of(f(a));\n    });\n};\nIOType.prototype.ap = function(a) {\n    return this.chain(function(f) {\n        return a.map(f);\n    });\n};\n\nexport const extendFn = function() {\n    Function.prototype.toIO = function() {\n        var self = this;\n        return function(x) { return IO(function() { return self(x) }); };\n    };\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./io.js\n **/","export function getRandomColor() {\n    var letters = '0123456789ABCDEF'.split('');\n    var color = '#';\n    for (var i = 0; i < 6; i++ ) {\n        color += letters[Math.floor(Math.random() * 16)];\n    }\n    return color;\n}\n\nexport function contrastColor(hexColor) {\n    return (hexdec(hexColor) > 0xffffff/2) ? '#000000' : '#FFFFFF';\n}\n\nfunction hexdec(hex_string) {\n    //  discuss at: http://phpjs.org/functions/hexdec/\n    // original by: Philippe Baumann\n    //   example 1: hexdec('that');\n    //   returns 1: 10\n    //   example 2: hexdec('a0');\n    //   returns 2: 160\n\n    hex_string = (hex_string + '')\n        .replace(/[^a-f0-9]/gi, '');\n    return parseInt(hex_string, 16);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./colors.js\n **/"],"sourceRoot":""}